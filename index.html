<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- SEO Meta Tags -->
    <title>Constellation Connect - Connect the Stars Browser Game</title>
    <meta name="description" content="Connect the stars to form beautiful constellations in this engaging HTML5 browser game. Play through 15 levels of increasing difficulty and learn about mythology.">
    <meta name="keywords" content="constellation game, star connect game, browser game, HTML5 game, puzzle game, astronomy game, educational game">
    <meta name="author" content="CodeByArt">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Constellation Connect - Connect the Stars Browser Game">
    <meta property="og:description" content="Connect the stars to form beautiful constellations in this engaging HTML5 browser game. Play through 15 levels of increasing difficulty.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.codebyart.com/constellation-connect">
    <meta property="og:image" content="https://www.codebyart.com/constellation-connect/preview.jpg">
    <meta property="og:site_name" content="CodeByArt Games">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Constellation Connect - Connect the Stars Browser Game">
    <meta name="twitter:description" content="Connect the stars to form beautiful constellations in this engaging HTML5 browser game.">
    <meta name="twitter:image" content="https://www.codebyart.com/constellation-connect/preview.jpg">
    
    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "VideoGame",
        "name": "Constellation Connect",
        "description": "Connect the stars to form beautiful constellations in this engaging HTML5 browser game. Play through 15 levels of increasing difficulty and learn about mythology.",
        "author": {
            "@type": "Organization",
            "name": "CodeByArt"
        },
        "gamePlatform": ["Web Browser", "HTML5"],
        "genre": ["Puzzle", "Educational"],
        "playMode": "SinglePlayer",
        "applicationCategory": "Game",
        "operatingSystem": "Any",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        }
    }
    </script>
    
    <style>
        /* CSS Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            background: radial-gradient(ellipse at top, #1a1f3a 0%, #0d0f1f 50%, #000000 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            margin: 0;
            padding: 0;
            /* Mobile touch optimizations */
            touch-action: none;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Full-screen game wrapper - NO AD SPACES */
        .codebyart-page-wrapper {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            /* Hardware acceleration */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }
        
        /* Main Game Container - Full Screen */
        .codebyart-game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            gap: 0;
            /* Hardware acceleration */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
        }
        
        /* Game Header - Hidden, info shown in canvas */
        .codebyart-game-header {
            display: none;
        }
        
        /* Canvas Container - Full Screen */
        .codebyart-canvas-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            background: transparent;
            /* Hardware acceleration */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
        }
        
        /* Game Canvas - Maximum Size */
        #codebyart-game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            box-shadow: none;
            background: radial-gradient(ellipse at center, #1a1f3a 0%, #0d0f1f 50%, #000000 100%);
            cursor: crosshair;
            /* Mobile touch optimizations */
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            /* Hardware acceleration */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        
        /* Canvas cursor states for better UX */
        #codebyart-game-canvas.codebyart-cursor-pointer {
            cursor: pointer;
        }
        
        #codebyart-game-canvas.codebyart-cursor-grab {
            cursor: grab;
        }
        
        #codebyart-game-canvas.codebyart-cursor-grabbing {
            cursor: grabbing;
        }
        
        /* ===== RESPONSIVE LAYOUT SYSTEM ===== */
        
        /* Desktop (default) - 1025px and above */
        @media (min-width: 1025px) {
            .codebyart-game-container {
                max-width: 100%;
            }
            
            .codebyart-canvas-wrapper {
                padding: 0;
            }
        }
        
        /* Tablet Landscape - 769px to 1024px */
        @media (min-width: 769px) and (max-width: 1024px) and (orientation: landscape) {
            .codebyart-game-container {
                max-width: 100%;
                padding: 0;
            }
            
            .codebyart-canvas-wrapper {
                padding: 0;
            }
        }
        
        /* Tablet Portrait - 481px to 768px */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: portrait) {
            .codebyart-game-container {
                padding: 0;
            }
            
            .codebyart-canvas-wrapper {
                padding: 0;
            }
        }
        
        /* Mobile Landscape - max 768px */
        @media (max-width: 768px) and (orientation: landscape) {
            body {
                overflow: hidden;
            }
            
            .codebyart-game-container {
                padding: 0;
            }
            
            .codebyart-canvas-wrapper {
                padding: 0;
            }
            
            .codebyart-page-wrapper {
                width: 100vw;
                height: 100vh;
            }
        }
        
        /* Mobile Portrait - max 480px */
        @media (max-width: 480px) and (orientation: portrait) {
            body {
                overflow: hidden;
            }
            
            .codebyart-game-container {
                padding: 0;
            }
            
            .codebyart-canvas-wrapper {
                padding: 0;
            }
            
            .codebyart-page-wrapper {
                width: 100vw;
                height: 100vh;
            }
        }
        
        /* Extra Small Mobile - max 360px */
        @media (max-width: 360px) {
            .codebyart-game-container {
                padding: 0;
            }
        }
        
        /* Large Desktop Screens - 1920px and above */
        @media (min-width: 1920px) {
            .codebyart-page-wrapper {
                max-width: 100vw;
            }
        }
        
        /* Extra Large Screens - 2560px and above */
        @media (min-width: 2560px) {
            .codebyart-page-wrapper {
                max-width: 2560px;
                margin: 0 auto;
            }
        }
        
        /* ===== END RESPONSIVE LAYOUT SYSTEM ===== */
        
        /* ===== MOBILE LAYOUT ADAPTATIONS ===== */
        
        /* Mobile Portrait - Compact HUD, bottom sheet buttons, reduced font sizes (20%) */
        @media (max-width: 480px) and (orientation: portrait) {
            /* Reduce all font sizes by 20% */
            body {
                font-size: 0.8rem;
            }
            
            /* Compact HUD styling */
            .glass-panel-hud {
                padding: 6px 10px;
                font-size: 0.75rem;
            }
            
            /* Bottom sheet button layout */
            .codebyart-canvas-wrapper {
                flex-direction: column;
            }
            
            /* Adjust button positioning for mobile portrait */
            .mobile-portrait-buttons {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                display: flex;
                justify-content: space-around;
                padding: 8px;
                background: rgba(10, 14, 39, 0.8);
                backdrop-filter: blur(10px);
            }
        }
        
        /* Mobile Landscape - Split HUD, side panel buttons, reduced font sizes (10%) */
        @media (max-width: 768px) and (orientation: landscape) {
            /* Reduce all font sizes by 10% */
            body {
                font-size: 0.9rem;
            }
            
            /* Split HUD styling */
            .glass-panel-hud {
                padding: 8px 12px;
                font-size: 0.85rem;
            }
            
            /* Side panel button layout */
            .mobile-landscape-buttons {
                position: fixed;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                display: flex;
                flex-direction: column;
                gap: 8px;
                padding: 8px;
                background: rgba(10, 14, 39, 0.8);
                backdrop-filter: blur(10px);
            }
        }
        
        /* Tablet Portrait - Full-width HUD, floating corner buttons, standard fonts */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: portrait) {
            /* Standard font sizes */
            body {
                font-size: 1rem;
            }
            
            /* Full-width HUD */
            .glass-panel-hud {
                width: 100%;
                max-width: 600px;
                margin: 0 auto;
                padding: 10px 15px;
            }
            
            /* Floating corner buttons */
            .tablet-portrait-buttons {
                position: fixed;
                display: flex;
                gap: 10px;
            }
            
            .tablet-portrait-buttons.top-right {
                top: 10px;
                right: 10px;
            }
            
            .tablet-portrait-buttons.bottom-right {
                bottom: 10px;
                right: 10px;
            }
        }
        
        /* Tablet Landscape - Full-width HUD, floating corner buttons, standard fonts */
        @media (min-width: 769px) and (max-width: 1024px) and (orientation: landscape) {
            /* Standard font sizes */
            body {
                font-size: 1rem;
            }
            
            /* Full-width HUD */
            .glass-panel-hud {
                width: 100%;
                max-width: 800px;
                margin: 0 auto;
                padding: 12px 20px;
            }
            
            /* Floating corner buttons */
            .tablet-landscape-buttons {
                position: fixed;
                display: flex;
                gap: 12px;
            }
        }
        
        /* Desktop - Centered HUD, fixed position buttons, standard/large fonts */
        @media (min-width: 1025px) {
            /* Standard to large font sizes */
            body {
                font-size: 1rem;
            }
            
            /* Centered HUD */
            .glass-panel-hud {
                max-width: 900px;
                margin: 0 auto;
                padding: 15px 25px;
            }
            
            /* Fixed position buttons */
            .desktop-buttons {
                position: fixed;
                display: flex;
                gap: 15px;
            }
        }
        
        /* Large Desktop - Larger fonts */
        @media (min-width: 1920px) {
            body {
                font-size: 1.1rem;
            }
            
            .glass-panel-hud {
                padding: 18px 30px;
                font-size: 1.1rem;
            }
        }
        
        /* ===== END MOBILE LAYOUT ADAPTATIONS ===== */
        
        /* ===== MODERN TYPOGRAPHY SYSTEM ===== */
        
        /* Modern font stack with system fonts for performance */
        body, .codebyart-game-container {
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Heading styles with bold weight */
        h1, h2, h3, h4, h5, h6,
        .heading {
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        
        /* Body text styles */
        .body-text {
            font-weight: 400;
            line-height: 1.5;
        }
        
        .body-text-medium {
            font-weight: 500;
            line-height: 1.5;
        }
        
        /* Text shadows for readability against complex backgrounds */
        .text-shadow-sm {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .text-shadow-md {
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        
        .text-shadow-lg {
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        
        /* ===== END MODERN TYPOGRAPHY SYSTEM ===== */
        
        /* ===== GLASSMORPHISM UI SYSTEM ===== */
        
        /* Base glass panel styling with frosted glass effect */
        .glass-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border-radius: 16px;
        }
        
        /* Glass panel with stronger blur for modals */
        .glass-panel-strong {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
            border-radius: 20px;
        }
        
        /* Glass panel for HUD elements */
        .glass-panel-hud {
            background: rgba(10, 14, 39, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border-radius: 12px;
        }
        
        /* Glass panel for buttons */
        .glass-panel-button {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        
        /* Fallback for browsers that don't support backdrop-filter */
        @supports not (backdrop-filter: blur(20px)) {
            .glass-panel,
            .glass-panel-strong,
            .glass-panel-hud,
            .glass-panel-button {
                background: rgba(10, 14, 39, 0.85);
            }
        }
        
        /* ===== END GLASSMORPHISM UI SYSTEM ===== */
    </style>
</head>
<body>
    <!-- Full-Screen Game Wrapper -->
    <div class="codebyart-page-wrapper">
        
        <!-- Full-Screen Game Container -->
        <main class="codebyart-game-container">
            <!-- Canvas Wrapper - Full Screen -->
            <div class="codebyart-canvas-wrapper">
                <canvas id="codebyart-game-canvas" width="1920" height="1080">
                    Your browser does not support the HTML5 canvas element. Please upgrade to a modern browser.
                </canvas>
            </div>
        </main>
        
    </div>
    
    <script>
        // ===== CONSTELLATION DATA STRUCTURE =====
        
        /**
         * Constellation data for all 15 levels
         * Positions are normalized (0-1) and will be scaled to canvas size
         * Connections define the target sequence players must follow
         */
        const codebyart_CONSTELLATION_DATA = [
            // ===== EASY LEVELS (3-5 stars) =====
            {
                id: 1,
                name: "Ursa Minor",
                commonName: "Little Dipper",
                difficulty: "easy",
                description: "The Little Bear constellation, home to Polaris, the North Star. In Greek mythology, this represents Arcas, son of Callisto, who was transformed into a bear by Zeus to protect him.",
                stars: [
                    { id: 0, x: 0.5, y: 0.3 },   // Polaris (North Star)
                    { id: 1, x: 0.45, y: 0.45 },
                    { id: 2, x: 0.4, y: 0.55 },
                    { id: 3, x: 0.5, y: 0.6 },
                    { id: 4, x: 0.6, y: 0.55 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 3 },
                    { from: 3, to: 4 }
                ],
                hints: 3
            },
            {
                id: 2,
                name: "Triangulum",
                commonName: "The Triangle",
                difficulty: "easy",
                description: "One of the smallest constellations, representing the Greek letter Delta. Ancient astronomers saw it as the Nile River delta or the island of Sicily.",
                stars: [
                    { id: 0, x: 0.5, y: 0.3 },
                    { id: 1, x: 0.35, y: 0.65 },
                    { id: 2, x: 0.65, y: 0.65 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 0 }
                ],
                hints: 3
            },
            {
                id: 3,
                name: "Corona Borealis",
                commonName: "Northern Crown",
                difficulty: "easy",
                description: "The Northern Crown, representing the crown given by Dionysus to Ariadne after she helped Theseus escape the Minotaur's labyrinth.",
                stars: [
                    { id: 0, x: 0.3, y: 0.5 },
                    { id: 1, x: 0.4, y: 0.35 },
                    { id: 2, x: 0.5, y: 0.3 },
                    { id: 3, x: 0.6, y: 0.35 },
                    { id: 4, x: 0.7, y: 0.5 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 3 },
                    { from: 3, to: 4 }
                ],
                hints: 3
            },
            {
                id: 4,
                name: "Delphinus",
                commonName: "The Dolphin",
                difficulty: "easy",
                description: "The Dolphin constellation represents the dolphin sent by Poseidon to find Amphitrite, who became his wife. As a reward, the dolphin was placed among the stars.",
                stars: [
                    { id: 0, x: 0.4, y: 0.4 },
                    { id: 1, x: 0.5, y: 0.35 },
                    { id: 2, x: 0.6, y: 0.4 },
                    { id: 3, x: 0.55, y: 0.55 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 1, to: 3 }
                ],
                hints: 3
            },
            {
                id: 5,
                name: "Sagitta",
                commonName: "The Arrow",
                difficulty: "easy",
                description: "The Arrow constellation, one of the smallest in the sky. It represents the arrow shot by either Hercules or Apollo in various Greek myths.",
                stars: [
                    { id: 0, x: 0.3, y: 0.5 },
                    { id: 1, x: 0.45, y: 0.45 },
                    { id: 2, x: 0.6, y: 0.5 },
                    { id: 3, x: 0.7, y: 0.48 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 3 }
                ],
                hints: 3
            },
            
            // ===== MEDIUM LEVELS (6-8 stars) =====
            {
                id: 6,
                name: "Orion's Belt",
                commonName: "The Hunter's Belt",
                difficulty: "medium",
                description: "The most recognizable part of Orion, the great hunter. The three belt stars are Alnitak, Alnilam, and Mintaka. Orion was placed in the sky by Zeus after his death.",
                stars: [
                    { id: 0, x: 0.5, y: 0.25 },   // Head
                    { id: 1, x: 0.4, y: 0.4 },    // Left shoulder
                    { id: 2, x: 0.6, y: 0.4 },    // Right shoulder
                    { id: 3, x: 0.45, y: 0.5 },   // Belt left
                    { id: 4, x: 0.5, y: 0.5 },    // Belt center
                    { id: 5, x: 0.55, y: 0.5 },   // Belt right
                    { id: 6, x: 0.4, y: 0.65 },   // Left foot
                    { id: 7, x: 0.6, y: 0.65 }    // Right foot
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 0, to: 2 },
                    { from: 1, to: 3 },
                    { from: 2, to: 5 },
                    { from: 3, to: 4 },
                    { from: 4, to: 5 },
                    { from: 3, to: 6 },
                    { from: 5, to: 7 }
                ],
                hints: 3
            },
            {
                id: 7,
                name: "Cassiopeia",
                commonName: "The Queen",
                difficulty: "medium",
                description: "The vain queen of Ethiopia who boasted about her beauty. As punishment, Poseidon placed her in the sky where she circles the North Pole, spending half the year upside down.",
                stars: [
                    { id: 0, x: 0.25, y: 0.5 },
                    { id: 1, x: 0.35, y: 0.35 },
                    { id: 2, x: 0.5, y: 0.4 },
                    { id: 3, x: 0.65, y: 0.35 },
                    { id: 4, x: 0.75, y: 0.5 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 3 },
                    { from: 3, to: 4 }
                ],
                hints: 3
            },
            {
                id: 8,
                name: "Leo",
                commonName: "The Lion",
                difficulty: "medium",
                description: "The Lion constellation represents the Nemean Lion slain by Hercules as his first labor. Its hide was impervious to weapons, so Hercules strangled it with his bare hands.",
                stars: [
                    { id: 0, x: 0.3, y: 0.4 },    // Head
                    { id: 1, x: 0.4, y: 0.35 },
                    { id: 2, x: 0.5, y: 0.3 },    // Regulus (heart)
                    { id: 3, x: 0.6, y: 0.4 },
                    { id: 4, x: 0.7, y: 0.5 },
                    { id: 5, x: 0.5, y: 0.55 },
                    { id: 6, x: 0.4, y: 0.6 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 3 },
                    { from: 3, to: 4 },
                    { from: 2, to: 5 },
                    { from: 5, to: 6 }
                ],
                hints: 3
            },
            {
                id: 9,
                name: "Lyra",
                commonName: "The Lyre",
                difficulty: "medium",
                description: "The Lyre of Orpheus, the legendary musician whose music could charm all living things. After his death, Zeus placed his lyre among the stars in his honor.",
                stars: [
                    { id: 0, x: 0.5, y: 0.3 },    // Vega
                    { id: 1, x: 0.45, y: 0.45 },
                    { id: 2, x: 0.55, y: 0.45 },
                    { id: 3, x: 0.4, y: 0.6 },
                    { id: 4, x: 0.5, y: 0.65 },
                    { id: 5, x: 0.6, y: 0.6 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 0, to: 2 },
                    { from: 1, to: 3 },
                    { from: 1, to: 4 },
                    { from: 2, to: 4 },
                    { from: 2, to: 5 }
                ],
                hints: 3
            },
            {
                id: 10,
                name: "Aquila",
                commonName: "The Eagle",
                difficulty: "medium",
                description: "The Eagle that carried Zeus's thunderbolts. In one myth, Zeus transformed into an eagle to abduct Ganymede, the most beautiful mortal, to serve as cupbearer to the gods.",
                stars: [
                    { id: 0, x: 0.5, y: 0.25 },   // Head
                    { id: 1, x: 0.5, y: 0.4 },    // Altair (body)
                    { id: 2, x: 0.35, y: 0.5 },   // Left wing
                    { id: 3, x: 0.65, y: 0.5 },   // Right wing
                    { id: 4, x: 0.45, y: 0.6 },
                    { id: 5, x: 0.55, y: 0.6 },
                    { id: 6, x: 0.5, y: 0.7 }     // Tail
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 1, to: 3 },
                    { from: 1, to: 4 },
                    { from: 1, to: 5 },
                    { from: 4, to: 6 },
                    { from: 5, to: 6 }
                ],
                hints: 3
            },
            
            // ===== ADVANCED LEVELS (9-12 stars) =====
            {
                id: 11,
                name: "Ursa Major",
                commonName: "Great Bear / Big Dipper",
                difficulty: "advanced",
                description: "The Great Bear, one of the most recognizable constellations. In Greek mythology, this is Callisto, a nymph transformed into a bear by Zeus's jealous wife Hera.",
                stars: [
                    { id: 0, x: 0.3, y: 0.4 },    // Dipper bowl
                    { id: 1, x: 0.35, y: 0.5 },
                    { id: 2, x: 0.4, y: 0.5 },
                    { id: 3, x: 0.45, y: 0.4 },
                    { id: 4, x: 0.5, y: 0.35 },   // Handle start
                    { id: 5, x: 0.55, y: 0.3 },
                    { id: 6, x: 0.6, y: 0.25 },
                    { id: 7, x: 0.35, y: 0.6 },   // Bear body
                    { id: 8, x: 0.4, y: 0.65 },
                    { id: 9, x: 0.25, y: 0.55 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 3 },
                    { from: 3, to: 0 },
                    { from: 3, to: 4 },
                    { from: 4, to: 5 },
                    { from: 5, to: 6 },
                    { from: 1, to: 7 },
                    { from: 7, to: 8 },
                    { from: 0, to: 9 }
                ],
                hints: 3
            },
            {
                id: 12,
                name: "Scorpius",
                commonName: "The Scorpion",
                difficulty: "advanced",
                description: "The Scorpion sent by Gaia to kill Orion after he boasted he could hunt any animal. Both were placed in the sky, but on opposite sides so they never meet.",
                stars: [
                    { id: 0, x: 0.3, y: 0.3 },    // Head
                    { id: 1, x: 0.35, y: 0.35 },
                    { id: 2, x: 0.4, y: 0.4 },    // Antares (heart)
                    { id: 3, x: 0.45, y: 0.45 },
                    { id: 4, x: 0.5, y: 0.5 },    // Body
                    { id: 5, x: 0.55, y: 0.55 },
                    { id: 6, x: 0.6, y: 0.6 },
                    { id: 7, x: 0.65, y: 0.65 },  // Tail
                    { id: 8, x: 0.7, y: 0.6 },    // Stinger
                    { id: 9, x: 0.25, y: 0.35 },  // Claws
                    { id: 10, x: 0.25, y: 0.4 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 3 },
                    { from: 3, to: 4 },
                    { from: 4, to: 5 },
                    { from: 5, to: 6 },
                    { from: 6, to: 7 },
                    { from: 7, to: 8 },
                    { from: 0, to: 9 },
                    { from: 9, to: 10 }
                ],
                hints: 3
            },
            {
                id: 13,
                name: "Sagittarius",
                commonName: "The Archer",
                difficulty: "advanced",
                description: "The Archer, often depicted as a centaur drawing a bow. Represents Chiron, the wise centaur who taught many Greek heroes including Achilles and Hercules.",
                stars: [
                    { id: 0, x: 0.35, y: 0.3 },   // Bow top
                    { id: 1, x: 0.4, y: 0.4 },
                    { id: 2, x: 0.35, y: 0.5 },   // Bow bottom
                    { id: 3, x: 0.5, y: 0.4 },    // Arrow
                    { id: 4, x: 0.6, y: 0.35 },
                    { id: 5, x: 0.5, y: 0.5 },    // Body
                    { id: 6, x: 0.55, y: 0.55 },
                    { id: 7, x: 0.6, y: 0.6 },
                    { id: 8, x: 0.45, y: 0.6 },   // Legs
                    { id: 9, x: 0.4, y: 0.65 },
                    { id: 10, x: 0.55, y: 0.65 },
                    { id: 11, x: 0.6, y: 0.7 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 1, to: 3 },
                    { from: 3, to: 4 },
                    { from: 1, to: 5 },
                    { from: 5, to: 6 },
                    { from: 6, to: 7 },
                    { from: 5, to: 8 },
                    { from: 8, to: 9 },
                    { from: 6, to: 10 },
                    { from: 10, to: 11 }
                ],
                hints: 3
            },
            {
                id: 14,
                name: "Pegasus",
                commonName: "The Winged Horse",
                difficulty: "advanced",
                description: "The divine winged horse born from Medusa's blood when Perseus beheaded her. Pegasus served Zeus by carrying his thunderbolts and was eventually transformed into a constellation.",
                stars: [
                    { id: 0, x: 0.3, y: 0.4 },    // Great Square
                    { id: 1, x: 0.5, y: 0.4 },
                    { id: 2, x: 0.5, y: 0.6 },
                    { id: 3, x: 0.3, y: 0.6 },
                    { id: 4, x: 0.25, y: 0.3 },   // Head/neck
                    { id: 5, x: 0.2, y: 0.25 },
                    { id: 6, x: 0.35, y: 0.5 },   // Wing
                    { id: 7, x: 0.3, y: 0.55 },
                    { id: 8, x: 0.4, y: 0.65 },   // Legs
                    { id: 9, x: 0.45, y: 0.7 }
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 2, to: 3 },
                    { from: 3, to: 0 },
                    { from: 0, to: 4 },
                    { from: 4, to: 5 },
                    { from: 0, to: 6 },
                    { from: 6, to: 7 },
                    { from: 3, to: 8 },
                    { from: 8, to: 9 }
                ],
                hints: 3
            },
            {
                id: 15,
                name: "Andromeda",
                commonName: "The Chained Princess",
                difficulty: "advanced",
                description: "Princess Andromeda, chained to a rock as sacrifice to a sea monster to appease Poseidon. She was rescued by Perseus, who she later married. Her mother was Cassiopeia.",
                stars: [
                    { id: 0, x: 0.5, y: 0.25 },   // Head
                    { id: 1, x: 0.5, y: 0.35 },   // Body
                    { id: 2, x: 0.5, y: 0.45 },
                    { id: 3, x: 0.35, y: 0.4 },   // Left arm
                    { id: 4, x: 0.25, y: 0.35 },
                    { id: 5, x: 0.65, y: 0.4 },   // Right arm
                    { id: 6, x: 0.75, y: 0.35 },
                    { id: 7, x: 0.45, y: 0.6 },   // Left leg
                    { id: 8, x: 0.4, y: 0.7 },
                    { id: 9, x: 0.55, y: 0.6 },   // Right leg
                    { id: 10, x: 0.6, y: 0.7 },
                    { id: 11, x: 0.5, y: 0.55 }   // Hip
                ],
                connections: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 1, to: 3 },
                    { from: 3, to: 4 },
                    { from: 1, to: 5 },
                    { from: 5, to: 6 },
                    { from: 2, to: 11 },
                    { from: 11, to: 7 },
                    { from: 7, to: 8 },
                    { from: 11, to: 9 },
                    { from: 9, to: 10 }
                ],
                hints: 3
            }
        ];
        
        // ===== END CONSTELLATION DATA STRUCTURE =====
        
        // ===== STORAGE MANAGER CLASS =====
        
        /**
         * codebyart_StorageManager - Handles all localStorage operations
         * Manages game progress, settings, and player data with error handling
         */
        class codebyart_StorageManager {
            constructor() {
                this.storageKey = 'codebyart_constellation_connect';
                this.settingsKey = 'codebyart_constellation_settings';
                this.storageAvailable = this.codebyart_checkStorageAvailability();
            }
            
            /**
             * Check if localStorage is available and working
             * @returns {boolean} True if localStorage is available
             */
            codebyart_checkStorageAvailability() {
                try {
                    const test = '__codebyart_storage_test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch (e) {
                    console.warn('localStorage is not available:', e);
                    return false;
                }
            }
            
            /**
             * Save player progress for a specific level
             * @param {number} levelNumber - The level number (1-15)
             * @param {number} stars - Star rating achieved (1-3)
             * @param {number} time - Completion time in seconds
             * @param {number} hintsUsed - Number of hints used
             * @returns {boolean} True if save was successful
             */
            codebyart_saveProgress(levelNumber, stars, time, hintsUsed = 0) {
                if (!this.storageAvailable) {
                    console.warn('Cannot save progress: localStorage not available');
                    return false;
                }
                
                try {
                    // Load existing progress
                    const progress = this.codebyart_loadProgress();
                    
                    // Initialize level data if it doesn't exist
                    if (!progress.levelData) {
                        progress.levelData = {};
                    }
                    
                    // Update or create level data
                    const existingLevel = progress.levelData[levelNumber];
                    const newLevelData = {
                        stars: stars,
                        bestTime: time,
                        hintsUsed: hintsUsed,
                        attempts: existingLevel ? existingLevel.attempts + 1 : 1,
                        lastPlayed: Date.now()
                    };
                    
                    // Only update best time if it's better
                    if (existingLevel && existingLevel.bestTime < time) {
                        newLevelData.bestTime = existingLevel.bestTime;
                    }
                    
                    // Only update stars if it's better
                    if (existingLevel && existingLevel.stars > stars) {
                        newLevelData.stars = existingLevel.stars;
                    }
                    
                    progress.levelData[levelNumber] = newLevelData;
                    
                    // Update completed levels list
                    if (!progress.completedLevels) {
                        progress.completedLevels = [];
                    }
                    if (!progress.completedLevels.includes(levelNumber)) {
                        progress.completedLevels.push(levelNumber);
                        progress.completedLevels.sort((a, b) => a - b);
                    }
                    
                    // Update total stats
                    progress.totalLevelsCompleted = progress.completedLevels.length;
                    progress.lastUpdated = Date.now();
                    
                    // Save to localStorage
                    localStorage.setItem(this.storageKey, JSON.stringify(progress));
                    
                    console.log(`Progress saved for level ${levelNumber}: ${stars} stars, ${time.toFixed(1)}s`);
                    return true;
                    
                } catch (e) {
                    console.error('Error saving progress:', e);
                    
                    // Handle quota exceeded error
                    if (e.name === 'QuotaExceededError') {
                        console.warn('Storage quota exceeded. Attempting to clear old data...');
                        this.codebyart_clearProgress();
                        return false;
                    }
                    
                    return false;
                }
            }
            
            /**
             * Load all player progress from localStorage
             * @returns {Object} Progress object with default values if not found
             */
            codebyart_loadProgress() {
                if (!this.storageAvailable) {
                    return this.codebyart_getDefaultProgress();
                }
                
                try {
                    const data = localStorage.getItem(this.storageKey);
                    
                    if (!data) {
                        return this.codebyart_getDefaultProgress();
                    }
                    
                    const progress = JSON.parse(data);
                    
                    // Validate and merge with defaults
                    return {
                        ...this.codebyart_getDefaultProgress(),
                        ...progress
                    };
                    
                } catch (e) {
                    console.error('Error loading progress:', e);
                    console.warn('Progress data may be corrupted. Returning defaults.');
                    
                    // If data is corrupted, clear it
                    try {
                        localStorage.removeItem(this.storageKey);
                    } catch (clearError) {
                        console.error('Error clearing corrupted data:', clearError);
                    }
                    
                    return this.codebyart_getDefaultProgress();
                }
            }
            
            /**
             * Get default progress structure
             * @returns {Object} Default progress object
             */
            codebyart_getDefaultProgress() {
                return {
                    playerName: '',
                    completedLevels: [],
                    levelData: {},
                    totalLevelsCompleted: 0,
                    lastUpdated: null
                };
            }
            
            /**
             * Save a specific setting
             * @param {string} key - Setting key
             * @param {*} value - Setting value
             * @returns {boolean} True if save was successful
             */
            codebyart_saveSetting(key, value) {
                if (!this.storageAvailable) {
                    console.warn('Cannot save setting: localStorage not available');
                    return false;
                }
                
                try {
                    const settings = this.codebyart_loadAllSettings();
                    settings[key] = value;
                    
                    localStorage.setItem(this.settingsKey, JSON.stringify(settings));
                    console.log(`Setting saved: ${key} = ${value}`);
                    return true;
                    
                } catch (e) {
                    console.error('Error saving setting:', e);
                    
                    // Handle quota exceeded error
                    if (e.name === 'QuotaExceededError') {
                        console.warn('Storage quota exceeded while saving setting');
                    }
                    
                    return false;
                }
            }
            
            /**
             * Load a specific setting
             * @param {string} key - Setting key
             * @param {*} defaultValue - Default value if setting not found
             * @returns {*} Setting value or default
             */
            codebyart_loadSetting(key, defaultValue = null) {
                if (!this.storageAvailable) {
                    return defaultValue;
                }
                
                try {
                    const settings = this.codebyart_loadAllSettings();
                    return settings.hasOwnProperty(key) ? settings[key] : defaultValue;
                    
                } catch (e) {
                    console.error('Error loading setting:', e);
                    return defaultValue;
                }
            }
            
            /**
             * Load all settings from localStorage
             * @returns {Object} Settings object
             */
            codebyart_loadAllSettings() {
                if (!this.storageAvailable) {
                    return this.codebyart_getDefaultSettings();
                }
                
                try {
                    const data = localStorage.getItem(this.settingsKey);
                    
                    if (!data) {
                        return this.codebyart_getDefaultSettings();
                    }
                    
                    const settings = JSON.parse(data);
                    
                    // Merge with defaults
                    return {
                        ...this.codebyart_getDefaultSettings(),
                        ...settings
                    };
                    
                } catch (e) {
                    console.error('Error loading settings:', e);
                    
                    // If data is corrupted, clear it
                    try {
                        localStorage.removeItem(this.settingsKey);
                    } catch (clearError) {
                        console.error('Error clearing corrupted settings:', clearError);
                    }
                    
                    return this.codebyart_getDefaultSettings();
                }
            }
            
            /**
             * Get default settings structure
             * @returns {Object} Default settings object
             */
            codebyart_getDefaultSettings() {
                return {
                    audioEnabled: true,
                    tutorialShown: false,
                    volume: 0.7
                };
            }
            
            /**
             * Clear all progress data (keeps settings)
             * @returns {boolean} True if clear was successful
             */
            codebyart_clearProgress() {
                if (!this.storageAvailable) {
                    console.warn('Cannot clear progress: localStorage not available');
                    return false;
                }
                
                try {
                    localStorage.removeItem(this.storageKey);
                    console.log('Progress data cleared');
                    return true;
                    
                } catch (e) {
                    console.error('Error clearing progress:', e);
                    return false;
                }
            }
            
            /**
             * Clear all settings data (keeps progress)
             * @returns {boolean} True if clear was successful
             */
            codebyart_clearSettings() {
                if (!this.storageAvailable) {
                    console.warn('Cannot clear settings: localStorage not available');
                    return false;
                }
                
                try {
                    localStorage.removeItem(this.settingsKey);
                    console.log('Settings data cleared');
                    return true;
                    
                } catch (e) {
                    console.error('Error clearing settings:', e);
                    return false;
                }
            }
            
            /**
             * Clear all data (progress and settings)
             * @returns {boolean} True if clear was successful
             */
            codebyart_clearAllData() {
                const progressCleared = this.codebyart_clearProgress();
                const settingsCleared = this.codebyart_clearSettings();
                return progressCleared && settingsCleared;
            }
            
            /**
             * Get storage usage information
             * @returns {Object} Storage info object
             */
            codebyart_getStorageInfo() {
                if (!this.storageAvailable) {
                    return {
                        available: false,
                        progressSize: 0,
                        settingsSize: 0,
                        totalSize: 0
                    };
                }
                
                try {
                    const progressData = localStorage.getItem(this.storageKey) || '';
                    const settingsData = localStorage.getItem(this.settingsKey) || '';
                    
                    return {
                        available: true,
                        progressSize: progressData.length,
                        settingsSize: settingsData.length,
                        totalSize: progressData.length + settingsData.length
                    };
                    
                } catch (e) {
                    console.error('Error getting storage info:', e);
                    return {
                        available: false,
                        progressSize: 0,
                        settingsSize: 0,
                        totalSize: 0
                    };
                }
            }
        }
        
        // ===== END STORAGE MANAGER CLASS =====
        
        // ===== AUDIO MANAGER CLASS =====
        
        /**
         * codebyart_AudioManager - Handles all audio operations using Web Audio API
         * Generates sound effects programmatically and manages audio state
         */
        class codebyart_AudioManager {
            constructor(storageManager) {
                this.storageManager = storageManager;
                this.audioContext = null;
                this.masterGain = null;
                this.isAudioAvailable = false;
                this.isMuted = false;
                this.volume = 0.7;
                
                // Initialize audio system
                this.codebyart_init();
            }
            
            /**
             * Initialize Web Audio API
             * Sets up audio context and master gain node
             */
            codebyart_init() {
                try {
                    // Check for Web Audio API support
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    
                    if (!AudioContext) {
                        console.warn('Web Audio API is not supported in this browser');
                        this.isAudioAvailable = false;
                        return;
                    }
                    
                    // Create audio context
                    this.audioContext = new AudioContext();
                    
                    // Create master gain node for volume control
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Load saved audio preferences
                    if (this.storageManager) {
                        this.isMuted = !this.storageManager.codebyart_loadSetting('audioEnabled', true);
                        this.volume = this.storageManager.codebyart_loadSetting('volume', 0.7);
                    }
                    
                    // Set initial volume
                    this.masterGain.gain.value = this.isMuted ? 0 : this.volume;
                    
                    this.isAudioAvailable = true;
                    console.log('AudioManager initialized successfully');
                    
                    // Resume audio context on user interaction (for browsers with autoplay restrictions)
                    this.codebyart_setupAutoplayResume();
                    
                } catch (e) {
                    console.error('Error initializing AudioManager:', e);
                    this.isAudioAvailable = false;
                }
            }
            
            /**
             * Setup autoplay resume for browsers with restrictions
             * Resumes audio context on first user interaction
             */
            codebyart_setupAutoplayResume() {
                if (!this.audioContext) return;
                
                const resumeAudio = () => {
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume().then(() => {
                            console.log('Audio context resumed');
                        }).catch(e => {
                            console.warn('Failed to resume audio context:', e);
                        });
                    }
                };
                
                // Resume on various user interactions
                document.addEventListener('click', resumeAudio, { once: true });
                document.addEventListener('touchstart', resumeAudio, { once: true });
                document.addEventListener('keydown', resumeAudio, { once: true });
            }
            
            /**
             * Play star selection sound (800Hz, 100ms)
             * Short beep when player selects a star
             */
            codebyart_playStarSelect() {
                if (!this.isAudioAvailable || this.isMuted) return;
                
                try {
                    const now = this.audioContext.currentTime;
                    
                    // Create oscillator for tone
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    // Connect nodes
                    oscillator.connect(gainNode);
                    gainNode.connect(this.masterGain);
                    
                    // Configure sound
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 800;
                    
                    // Envelope: quick attack and release
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                    
                    // Play sound
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    
                } catch (e) {
                    console.error('Error playing star select sound:', e);
                }
            }
            
            /**
             * Play connection made sound (600-800Hz rising, 150ms)
             * Rising tone when a valid connection is made
             */
            codebyart_playConnectionMade() {
                if (!this.isAudioAvailable || this.isMuted) return;
                
                try {
                    const now = this.audioContext.currentTime;
                    
                    // Create oscillator for tone
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    // Connect nodes
                    oscillator.connect(gainNode);
                    gainNode.connect(this.masterGain);
                    
                    // Configure sound with rising frequency
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(600, now);
                    oscillator.frequency.linearRampToValueAtTime(800, now + 0.15);
                    
                    // Envelope
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(0.25, now + 0.02);
                    gainNode.gain.linearRampToValueAtTime(0.25, now + 0.12);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
                    
                    // Play sound
                    oscillator.start(now);
                    oscillator.stop(now + 0.15);
                    
                } catch (e) {
                    console.error('Error playing connection made sound:', e);
                }
            }
            
            /**
             * Play connection error sound (200Hz buzz, 200ms)
             * Low buzz when an incorrect connection is made
             */
            codebyart_playConnectionError() {
                if (!this.isAudioAvailable || this.isMuted) return;
                
                try {
                    const now = this.audioContext.currentTime;
                    
                    // Create oscillator for buzz
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    // Connect nodes
                    oscillator.connect(gainNode);
                    gainNode.connect(this.masterGain);
                    
                    // Configure sound - square wave for harsh buzz
                    oscillator.type = 'square';
                    oscillator.frequency.value = 200;
                    
                    // Envelope with slight vibrato
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(0.2, now + 0.02);
                    gainNode.gain.linearRampToValueAtTime(0.2, now + 0.18);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                    
                    // Play sound
                    oscillator.start(now);
                    oscillator.stop(now + 0.2);
                    
                } catch (e) {
                    console.error('Error playing connection error sound:', e);
                }
            }
            
            /**
             * Play level complete sound (ascending arpeggio)
             * Celebratory ascending notes when level is completed
             */
            codebyart_playLevelComplete() {
                if (!this.isAudioAvailable || this.isMuted) return;
                
                try {
                    const now = this.audioContext.currentTime;
                    
                    // Arpeggio notes (C major chord: C, E, G, C)
                    const notes = [523.25, 659.25, 783.99, 1046.50];
                    const noteDuration = 0.15;
                    const noteGap = 0.02;
                    
                    notes.forEach((frequency, index) => {
                        const startTime = now + (index * (noteDuration + noteGap));
                        
                        // Create oscillator for each note
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        // Connect nodes
                        oscillator.connect(gainNode);
                        gainNode.connect(this.masterGain);
                        
                        // Configure sound
                        oscillator.type = 'sine';
                        oscillator.frequency.value = frequency;
                        
                        // Envelope
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.02);
                        gainNode.gain.linearRampToValueAtTime(0.2, startTime + noteDuration - 0.05);
                        gainNode.gain.linearRampToValueAtTime(0, startTime + noteDuration);
                        
                        // Play note
                        oscillator.start(startTime);
                        oscillator.stop(startTime + noteDuration);
                    });
                    
                } catch (e) {
                    console.error('Error playing level complete sound:', e);
                }
            }
            
            /**
             * Play hint sound (gentle chime)
             * Soft chime when player uses a hint
             */
            codebyart_playHintSound() {
                if (!this.isAudioAvailable || this.isMuted) return;
                
                try {
                    const now = this.audioContext.currentTime;
                    
                    // Create two oscillators for a pleasant chime (perfect fifth interval)
                    const frequencies = [880, 1320]; // A5 and E6
                    
                    frequencies.forEach((frequency, index) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        // Connect nodes
                        oscillator.connect(gainNode);
                        gainNode.connect(this.masterGain);
                        
                        // Configure sound
                        oscillator.type = 'sine';
                        oscillator.frequency.value = frequency;
                        
                        // Envelope - gentle fade in and out
                        const volume = index === 0 ? 0.2 : 0.15; // First note slightly louder
                        gainNode.gain.setValueAtTime(0, now);
                        gainNode.gain.linearRampToValueAtTime(volume, now + 0.05);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                        
                        // Play sound
                        oscillator.start(now);
                        oscillator.stop(now + 0.8);
                    });
                    
                } catch (e) {
                    console.error('Error playing hint sound:', e);
                }
            }
            
            /**
             * Toggle mute on/off
             * Persists preference to localStorage
             * @returns {boolean} New mute state (true = muted)
             */
            codebyart_toggleMute() {
                if (!this.isAudioAvailable) {
                    console.warn('Cannot toggle mute: Audio not available');
                    return true;
                }
                
                try {
                    this.isMuted = !this.isMuted;
                    
                    // Update master gain
                    if (this.masterGain) {
                        this.masterGain.gain.value = this.isMuted ? 0 : this.volume;
                    }
                    
                    // Save preference to localStorage
                    if (this.storageManager) {
                        this.storageManager.codebyart_saveSetting('audioEnabled', !this.isMuted);
                    }
                    
                    console.log(`Audio ${this.isMuted ? 'muted' : 'unmuted'}`);
                    return this.isMuted;
                    
                } catch (e) {
                    console.error('Error toggling mute:', e);
                    return this.isMuted;
                }
            }
            
            /**
             * Set master volume level
             * @param {number} level - Volume level (0.0 to 1.0)
             */
            codebyart_setVolume(level) {
                if (!this.isAudioAvailable) return;
                
                try {
                    // Clamp volume between 0 and 1
                    this.volume = Math.max(0, Math.min(1, level));
                    
                    // Update master gain if not muted
                    if (this.masterGain && !this.isMuted) {
                        this.masterGain.gain.value = this.volume;
                    }
                    
                    // Save preference to localStorage
                    if (this.storageManager) {
                        this.storageManager.codebyart_saveSetting('volume', this.volume);
                    }
                    
                    console.log(`Volume set to ${(this.volume * 100).toFixed(0)}%`);
                    
                } catch (e) {
                    console.error('Error setting volume:', e);
                }
            }
            
            /**
             * Get current mute state
             * @returns {boolean} True if muted
             */
            codebyart_isMuted() {
                return this.isMuted;
            }
            
            /**
             * Get current volume level
             * @returns {number} Volume level (0.0 to 1.0)
             */
            codebyart_getVolume() {
                return this.volume;
            }
            
            /**
             * Check if audio is available
             * @returns {boolean} True if Web Audio API is available
             */
            codebyart_isAvailable() {
                return this.isAudioAvailable;
            }
            
            /**
             * Cleanup audio resources
             * Should be called when game is destroyed
             */
            codebyart_destroy() {
                try {
                    if (this.audioContext && this.audioContext.state !== 'closed') {
                        this.audioContext.close();
                        console.log('Audio context closed');
                    }
                } catch (e) {
                    console.error('Error destroying AudioManager:', e);
                }
            }
        }
        
        // ===== END AUDIO MANAGER CLASS =====
        
        // ===== STAR NODE CLASS =====
        
        /**
         * codebyart_StarNode - Represents an interactive star in the constellation
         * Handles rendering, animations, selection state, and collision detection
         */
        class codebyart_StarNode {
            constructor(x, y, id, size = 8) {
                // Position properties
                this.x = x;
                this.y = y;
                this.id = id;
                
                // Size properties
                this.baseSize = size;
                this.size = size;
                this.touchTargetSize = Math.max(44, size * 2); // Minimum 44px for accessibility
                
                // State properties
                this.isSelected = false;
                this.isConnected = false;
                this.isHovered = false;
                this.isHinted = false;
                
                // Animation properties
                this.glowPhase = 0; // 0 to 2 for glow animation
                this.glowSpeed = 0.003; // Radians per millisecond
                this.pulsePhase = 0; // 0 to 2 for pulse animation
                this.pulseSpeed = 0.002; // Radians per millisecond
                this.glowIntensity = 0; // 0 to 1 for hover glow
                this.glowTargetIntensity = 0;
                this.glowTransitionSpeed = 0.005; // Transition speed for hover glow (200ms fade-in)
                
                // Selection pulse animation (400ms)
                this.selectionPulseActive = false;
                this.selectionPulseProgress = 0; // 0 to 1
                this.selectionPulseDuration = 400; // milliseconds
                
                // Error flash animation (300ms)
                this.errorFlashActive = false;
                this.errorFlashProgress = 0; // 0 to 1
                this.errorFlashDuration = 300; // milliseconds
                
                // Visual properties
                this.baseColor = { r: 200, g: 220, b: 255 }; // Light blue-white
                this.selectedColor = { r: 100, g: 200, b: 255 }; // Bright blue
                this.connectedColor = { r: 150, g: 150, b: 200 }; // Dimmed purple
                this.hintColor = { r: 255, g: 220, b: 100 }; // Golden yellow
                this.errorColor = { r: 255, g: 80, b: 80 }; // Red for errors
            }
            
            /**
             * Update star animation state
             * @param {number} deltaTime - Time elapsed since last update in milliseconds
             */
            codebyart_update(deltaTime) {
                // Update glow animation phase (200-400ms cycle)
                this.glowPhase += this.glowSpeed * deltaTime;
                if (this.glowPhase > Math.PI * 2) {
                    this.glowPhase -= Math.PI * 2;
                }
                
                // Update pulse animation phase for default state
                this.pulsePhase += this.pulseSpeed * deltaTime;
                if (this.pulsePhase > Math.PI * 2) {
                    this.pulsePhase -= Math.PI * 2;
                }
                
                // Smooth transition for hover glow intensity (200ms fade-in)
                if (this.glowIntensity < this.glowTargetIntensity) {
                    this.glowIntensity = Math.min(
                        this.glowTargetIntensity,
                        this.glowIntensity + this.glowTransitionSpeed * deltaTime
                    );
                } else if (this.glowIntensity > this.glowTargetIntensity) {
                    this.glowIntensity = Math.max(
                        this.glowTargetIntensity,
                        this.glowIntensity - this.glowTransitionSpeed * deltaTime
                    );
                }
                
                // Update selection pulse animation (400ms)
                if (this.selectionPulseActive) {
                    this.selectionPulseProgress += deltaTime / this.selectionPulseDuration;
                    if (this.selectionPulseProgress >= 1) {
                        this.selectionPulseProgress = 1;
                        this.selectionPulseActive = false;
                    }
                }
                
                // Update error flash animation (300ms)
                if (this.errorFlashActive) {
                    this.errorFlashProgress += deltaTime / this.errorFlashDuration;
                    if (this.errorFlashProgress >= 1) {
                        this.errorFlashProgress = 0;
                        this.errorFlashActive = false;
                    }
                }
            }
            
            /**
             * Render the star with current visual state
             * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
             */
            codebyart_render(ctx) {
                ctx.save();
                
                // Ensure colors are initialized (safety check)
                if (!this.baseColor || typeof this.baseColor.r === 'undefined') {
                    this.baseColor = { r: 200, g: 220, b: 255 };
                }
                if (!this.selectedColor || typeof this.selectedColor.r === 'undefined') {
                    this.selectedColor = { r: 100, g: 200, b: 255 };
                }
                if (!this.connectedColor || typeof this.connectedColor.r === 'undefined') {
                    this.connectedColor = { r: 150, g: 150, b: 200 };
                }
                if (!this.hintColor || typeof this.hintColor.r === 'undefined') {
                    this.hintColor = { r: 255, g: 220, b: 100 };
                }
                
                // Determine current color based on state
                let color = this.baseColor;
                
                // Validate color has all required properties
                if (!color || typeof color.r === 'undefined' || typeof color.g === 'undefined' || typeof color.b === 'undefined') {
                    color = { r: 200, g: 220, b: 255 }; // Fallback to default
                }
                let glowSize = this.size * 2;
                let coreSize = this.size;
                
                if (this.isHinted) {
                    // Hinted state - golden glow with pulsing
                    color = this.hintColor;
                    const hintPulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
                    glowSize = this.size * 4 * hintPulse;
                    coreSize = this.size * 1.2;
                } else if (this.isSelected) {
                    // Selected state - bright blue with strong glow
                    color = this.selectedColor;
                    glowSize = this.size * 3;
                    coreSize = this.size * 1.3;
                } else if (this.isConnected) {
                    // Connected state - dimmed with subtle glow
                    color = this.connectedColor;
                    glowSize = this.size * 1.5;
                    coreSize = this.size * 0.9;
                } else {
                    // Default state - pulsing animation
                    const pulseFactor = Math.sin(this.pulsePhase) * 0.15 + 0.85;
                    coreSize = this.size * pulseFactor;
                    glowSize = this.size * 2 * pulseFactor;
                }
                
                // Add selection pulse animation (400ms)
                if (this.selectionPulseActive) {
                    // Pulse: 0 -> 1 -> 0.5 over 400ms
                    const pulseIntensity = this.selectionPulseProgress < 0.5 
                        ? this.selectionPulseProgress * 2  // 0 to 1 in first half
                        : 1 - (this.selectionPulseProgress - 0.5);  // 1 to 0.5 in second half
                    glowSize *= (1 + pulseIntensity * 0.3);
                    coreSize *= (1 + pulseIntensity * 0.3);
                }
                
                // Add hover glow effect (200ms fade-in)
                if (this.isHovered || this.glowIntensity > 0) {
                    const hoverGlowFactor = 1 + (this.glowIntensity * 0.5);
                    glowSize *= hoverGlowFactor;
                    coreSize *= (1 + this.glowIntensity * 0.2);
                }
                
                // Override color for error flash (300ms red flash)
                if (this.errorFlashActive) {
                    const flashIntensity = 1 - this.errorFlashProgress; // Fade out over 300ms
                    color = {
                        r: this.errorColor.r * flashIntensity + color.r * (1 - flashIntensity),
                        g: this.errorColor.g * flashIntensity + color.g * (1 - flashIntensity),
                        b: this.errorColor.b * flashIntensity + color.b * (1 - flashIntensity)
                    };
                }
                
                // Render outer glow with animation
                const glowAnimation = Math.sin(this.glowPhase) * 0.2 + 0.8;
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize * glowAnimation
                );
                
                // Ensure color values are valid numbers
                const r = Math.floor(color.r) || 200;
                const g = Math.floor(color.g) || 220;
                const b = Math.floor(color.b) || 255;
                
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
                gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.4)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize * glowAnimation, 0, Math.PI * 2);
                ctx.fill();
                
                // Render star core
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, coreSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Add bright center point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, coreSize * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Render selection ring for selected stars
                if (this.isSelected) {
                    const ringAnimation = Math.sin(this.glowPhase * 2) * 0.1 + 0.9;
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.6 * ringAnimation})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, coreSize * 2 * ringAnimation, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Debug: Render touch target area (uncomment for debugging)
                // ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                // ctx.lineWidth = 1;
                // ctx.beginPath();
                // ctx.arc(this.x, this.y, this.touchTargetSize / 2, 0, Math.PI * 2);
                // ctx.stroke();
                
                ctx.restore();
            }
            
            /**
             * Check if a point is inside the star's touch target
             * Uses minimum 44px touch target for accessibility
             * @param {number} x - X coordinate to check
             * @param {number} y - Y coordinate to check
             * @returns {boolean} True if point is inside touch target
             */
            codebyart_isPointInside(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const distanceSquared = dx * dx + dy * dy;
                const radiusSquared = (this.touchTargetSize / 2) * (this.touchTargetSize / 2);
                
                return distanceSquared <= radiusSquared;
            }
            
            /**
             * Select this star
             * Changes visual state to selected
             * Triggers selection pulse animation (400ms)
             */
            codebyart_select() {
                this.isSelected = true;
                this.isHinted = false; // Clear hint state when selected
                
                // Trigger selection pulse animation
                this.selectionPulseActive = true;
                this.selectionPulseProgress = 0;
            }
            
            /**
             * Trigger error flash effect (300ms red flash)
             * Used when an incorrect connection is made
             */
            codebyart_triggerErrorFlash() {
                this.errorFlashActive = true;
                this.errorFlashProgress = 0;
            }
            
            /**
             * Deselect this star
             * Returns to default or connected state
             */
            codebyart_deselect() {
                this.isSelected = false;
            }
            
            /**
             * Mark this star as connected
             * Changes visual state to show it's part of a connection
             */
            codebyart_setConnected(connected) {
                this.isConnected = connected;
            }
            
            /**
             * Set hover state for this star
             * Triggers glow animation
             * @param {boolean} active - True to activate hover glow
             */
            codebyart_setGlow(active) {
                this.isHovered = active;
                this.glowTargetIntensity = active ? 1 : 0;
            }
            
            /**
             * Set hint state for this star
             * Shows golden glow to indicate this is the next star to connect
             * @param {boolean} active - True to show hint
             */
            codebyart_setHint(active) {
                this.isHinted = active;
            }
            
            /**
             * Reset star to default state
             * Clears all state flags
             */
            codebyart_reset() {
                this.isSelected = false;
                this.isConnected = false;
                this.isHovered = false;
                this.isHinted = false;
                this.glowTargetIntensity = 0;
            }
            
            /**
             * Get star position
             * @returns {Object} Object with x and y coordinates
             */
            codebyart_getPosition() {
                return { x: this.x, y: this.y };
            }
            
            /**
             * Set star position
             * @param {number} x - New X coordinate
             * @param {number} y - New Y coordinate
             */
            codebyart_setPosition(x, y) {
                this.x = x;
                this.y = y;
            }
            
            /**
             * Get star ID
             * @returns {number} Star ID
             */
            codebyart_getId() {
                return this.id;
            }
            
            /**
             * Check if star is selected
             * @returns {boolean} True if selected
             */
            codebyart_isSelected() {
                return this.isSelected;
            }
            
            /**
             * Check if star is connected
             * @returns {boolean} True if connected
             */
            codebyart_isConnected() {
                return this.isConnected;
            }
        }
        
        // ===== END STAR NODE CLASS =====
        
        // ===== CONNECTION MANAGER CLASS =====
        
        /**
         * codebyart_ConnectionManager - Manages player connections between stars
         * Handles connection validation, rendering, and animations
         */
        class codebyart_ConnectionManager {
            constructor() {
                // Array to store player connections: [{from: starId, to: starId, animationProgress: 0-1}, ...]
                this.connections = [];
                
                // Target sequence for validation (set by level manager)
                this.targetSequence = [];
                
                // Animation properties
                this.animationDuration = 200; // milliseconds for line drawing animation (Requirement 7.1)
                this.pulsePhase = 0; // 0 to 2 for pulsing animation
                this.pulseSpeed = 0.002; // Radians per millisecond
                
                // Visual properties
                this.lineWidth = 3;
                this.lineColor = { r: 100, g: 200, b: 255 }; // Bright blue
                this.correctLineColor = { r: 100, g: 255, b: 150 }; // Green for correct
                this.incorrectLineColor = { r: 255, g: 100, b: 100 }; // Red for incorrect
            }
            
            /**
             * Add a new connection between two stars
             * Prevents duplicate connections and self-connections
             * @param {number} fromStarId - ID of the starting star
             * @param {number} toStarId - ID of the ending star
             * @returns {boolean} True if connection was added successfully
             */
            codebyart_addConnection(fromStarId, toStarId) {
                // Validate star IDs are numbers
                if (typeof fromStarId !== 'number' || typeof toStarId !== 'number') {
                    console.error(`Invalid star IDs: fromStarId=${fromStarId}, toStarId=${toStarId}. Must be numbers.`);
                    return false;
                }
                
                // Validate star IDs are non-negative integers
                if (fromStarId < 0 || toStarId < 0 || !Number.isInteger(fromStarId) || !Number.isInteger(toStarId)) {
                    console.error(`Invalid star IDs: fromStarId=${fromStarId}, toStarId=${toStarId}. Must be non-negative integers.`);
                    return false;
                }
                
                // Prevent self-connections (star to itself)
                if (fromStarId === toStarId) {
                    console.warn(`Cannot connect star ${fromStarId} to itself`);
                    return false;
                }
                
                // Check for duplicate connections (same direction)
                const isDuplicate = this.connections.some(conn => 
                    conn.from === fromStarId && conn.to === toStarId
                );
                
                if (isDuplicate) {
                    console.warn(`Connection from ${fromStarId} to ${toStarId} already exists`);
                    return false;
                }
                
                // Check for reverse duplicate (connection in opposite direction)
                const isReverseDuplicate = this.connections.some(conn => 
                    conn.from === toStarId && conn.to === fromStarId
                );
                
                if (isReverseDuplicate) {
                    console.warn(`Reverse connection from ${toStarId} to ${fromStarId} already exists`);
                    return false;
                }
                
                // Add the connection with animation state
                try {
                    const connection = {
                        from: fromStarId,
                        to: toStarId,
                        animationProgress: 0, // 0 to 1 for drawing animation
                        animationStartTime: performance.now(),
                        isAnimating: true
                    };
                    
                    this.connections.push(connection);
                    console.log(`Connection added: ${fromStarId}  ${toStarId}`);
                    
                    return true;
                } catch (e) {
                    console.error('Error adding connection:', e);
                    return false;
                }
            }
            
            /**
             * Validate the current connection sequence against the target
             * @param {Array} targetSequence - Array of target connections [{from, to}, ...]
             * @returns {Object} Validation result with status and details
             */
            codebyart_validateSequence(targetSequence) {
                // Store target sequence for reference
                this.targetSequence = targetSequence || [];
                
                // If no connections made yet
                if (this.connections.length === 0) {
                    return {
                        isValid: false,
                        isComplete: false,
                        correctCount: 0,
                        totalRequired: this.targetSequence.length,
                        message: 'No connections made yet'
                    };
                }
                
                // Count correct connections
                let correctCount = 0;
                const connectionMatches = [];
                
                // Check each player connection against target
                this.connections.forEach((playerConn, index) => {
                    const isCorrect = this.targetSequence.some(targetConn => 
                        targetConn.from === playerConn.from && targetConn.to === playerConn.to
                    );
                    
                    connectionMatches.push({
                        index: index,
                        from: playerConn.from,
                        to: playerConn.to,
                        isCorrect: isCorrect
                    });
                    
                    if (isCorrect) {
                        correctCount++;
                    }
                });
                
                // Check if sequence is complete and correct
                const isComplete = this.connections.length === this.targetSequence.length;
                const isValid = isComplete && correctCount === this.targetSequence.length;
                
                // Calculate accuracy percentage
                const accuracy = this.targetSequence.length > 0 
                    ? (correctCount / this.targetSequence.length) * 100 
                    : 0;
                
                return {
                    isValid: isValid,
                    isComplete: isComplete,
                    correctCount: correctCount,
                    totalRequired: this.targetSequence.length,
                    totalMade: this.connections.length,
                    accuracy: accuracy,
                    connectionMatches: connectionMatches,
                    message: isValid 
                        ? 'Constellation complete!' 
                        : isComplete 
                            ? `${correctCount} of ${this.targetSequence.length} connections correct`
                            : `${correctCount} correct, ${this.targetSequence.length - this.connections.length} more needed`
                };
            }
            
            /**
             * Clear all connections (for level reset)
             */
            codebyart_clearConnections() {
                this.connections = [];
                console.log('All connections cleared');
            }
            
            /**
             * Get connection lines for rendering
             * Returns array of connection data with star positions
             * @param {Array} stars - Array of StarNode objects
             * @returns {Array} Array of connection line data
             */
            codebyart_getConnectionLines(stars) {
                if (!stars || stars.length === 0) {
                    return [];
                }
                
                const lines = [];
                
                this.connections.forEach(conn => {
                    // Find the star objects
                    const fromStar = stars.find(star => star.codebyart_getId() === conn.from);
                    const toStar = stars.find(star => star.codebyart_getId() === conn.to);
                    
                    if (fromStar && toStar) {
                        const fromPos = fromStar.codebyart_getPosition();
                        const toPos = toStar.codebyart_getPosition();
                        
                        // Check if this connection is correct
                        const isCorrect = this.targetSequence.some(targetConn => 
                            targetConn.from === conn.from && targetConn.to === conn.to
                        );
                        
                        lines.push({
                            fromX: fromPos.x,
                            fromY: fromPos.y,
                            toX: toPos.x,
                            toY: toPos.y,
                            fromId: conn.from,
                            toId: conn.to,
                            animationProgress: conn.animationProgress,
                            isAnimating: conn.isAnimating,
                            isCorrect: isCorrect
                        });
                    }
                });
                
                return lines;
            }
            
            /**
             * Update connection animations
             * @param {number} deltaTime - Time elapsed since last update in milliseconds
             */
            codebyart_updateAnimations(deltaTime) {
                // Update pulse phase for pulsing animation
                this.pulsePhase += this.pulseSpeed * deltaTime;
                if (this.pulsePhase > Math.PI * 2) {
                    this.pulsePhase -= Math.PI * 2;
                }
                
                // Update line drawing animations
                this.connections.forEach(conn => {
                    if (conn.isAnimating) {
                        const elapsed = performance.now() - conn.animationStartTime;
                        conn.animationProgress = Math.min(1, elapsed / this.animationDuration);
                        
                        // Stop animating when complete
                        if (conn.animationProgress >= 1) {
                            conn.isAnimating = false;
                        }
                    }
                });
            }
            
            /**
             * Animate a connection with smooth line drawing
             * This is called automatically when a connection is added
             * @param {Object} connection - Connection object
             * @param {number} duration - Animation duration in milliseconds (default 200ms per Requirement 7.1)
             */
            codebyart_animateConnection(connection, duration = 200) {
                if (connection) {
                    connection.animationProgress = 0;
                    connection.animationStartTime = performance.now();
                    connection.isAnimating = true;
                    this.animationDuration = duration;
                }
            }
            
            /**
             * Render all connection lines with animations and effects
             * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
             * @param {Array} stars - Array of StarNode objects
             */
            codebyart_renderConnections(ctx, stars) {
                if (!ctx || !stars) return;
                
                const lines = this.codebyart_getConnectionLines(stars);
                
                if (lines.length === 0) return;
                
                ctx.save();
                
                // Render each connection line
                lines.forEach(line => {
                    // Calculate animated end point for drawing animation
                    const progress = line.animationProgress;
                    const currentToX = line.fromX + (line.toX - line.fromX) * progress;
                    const currentToY = line.fromY + (line.toY - line.fromY) * progress;
                    
                    // Determine line color based on correctness
                    let color = this.lineColor;
                    if (this.targetSequence.length > 0) {
                        color = line.isCorrect ? this.correctLineColor : this.incorrectLineColor;
                    }
                    
                    // Validate color values
                    const r = Math.floor(color?.r) || 100;
                    const g = Math.floor(color?.g) || 200;
                    const b = Math.floor(color?.b) || 255;
                    
                    // Add pulsing effect to line width
                    const pulseFactor = Math.sin(this.pulsePhase) * 0.2 + 0.8;
                    const currentLineWidth = this.lineWidth * pulseFactor;
                    
                    // Draw outer glow
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                    ctx.lineWidth = currentLineWidth * 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.fromX, line.fromY);
                    ctx.lineTo(currentToX, currentToY);
                    ctx.stroke();
                    
                    // Draw gradient line
                    const gradient = ctx.createLinearGradient(
                        line.fromX, line.fromY,
                        currentToX, currentToY
                    );
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
                    gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 1)`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.8)`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = currentLineWidth;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.fromX, line.fromY);
                    ctx.lineTo(currentToX, currentToY);
                    ctx.stroke();
                    
                    // Draw bright center line
                    ctx.strokeStyle = `rgba(255, 255, 255, 0.6)`;
                    ctx.lineWidth = currentLineWidth * 0.3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.fromX, line.fromY);
                    ctx.lineTo(currentToX, currentToY);
                    ctx.stroke();
                    
                    // Draw animated particles along the line (only for completed animations)
                    if (!line.isAnimating) {
                        const numParticles = 3;
                        const particlePhase = (this.pulsePhase * 2) % (Math.PI * 2);
                        
                        for (let i = 0; i < numParticles; i++) {
                            const particleProgress = ((particlePhase / (Math.PI * 2)) + (i / numParticles)) % 1;
                            const particleX = line.fromX + (line.toX - line.fromX) * particleProgress;
                            const particleY = line.fromY + (line.toY - line.fromY) * particleProgress;
                            
                            // Draw particle glow
                            const particleGradient = ctx.createRadialGradient(
                                particleX, particleY, 0,
                                particleX, particleY, 4
                            );
                            particleGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
                            particleGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                            
                            ctx.fillStyle = particleGradient;
                            ctx.beginPath();
                            ctx.arc(particleX, particleY, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
                
                ctx.restore();
            }
            
            /**
             * Get the number of connections made
             * @returns {number} Number of connections
             */
            codebyart_getConnectionCount() {
                return this.connections.length;
            }
            
            /**
             * Get the last connection made
             * @returns {Object|null} Last connection or null if none
             */
            codebyart_getLastConnection() {
                if (this.connections.length === 0) return null;
                return this.connections[this.connections.length - 1];
            }
            
            /**
             * Remove the last connection (undo)
             * @returns {boolean} True if a connection was removed
             */
            codebyart_removeLastConnection() {
                if (this.connections.length === 0) {
                    console.warn('No connections to remove');
                    return false;
                }
                
                const removed = this.connections.pop();
                console.log(`Connection removed: ${removed.from}  ${removed.to}`);
                return true;
            }
            
            /**
             * Check if a specific connection exists
             * @param {number} fromStarId - Starting star ID
             * @param {number} toStarId - Ending star ID
             * @returns {boolean} True if connection exists
             */
            codebyart_hasConnection(fromStarId, toStarId) {
                return this.connections.some(conn => 
                    conn.from === fromStarId && conn.to === toStarId
                );
            }
            
            /**
             * Set the target sequence for validation
             * @param {Array} targetSequence - Array of target connections [{from, to}, ...]
             */
            codebyart_setTargetSequence(targetSequence) {
                this.targetSequence = targetSequence || [];
                console.log(`Target sequence set: ${this.targetSequence.length} connections`);
            }
            
            /**
             * Get all connections
             * @returns {Array} Array of connection objects
             */
            codebyart_getConnections() {
                return [...this.connections]; // Return a copy
            }
            
            /**
             * Reset the connection manager
             * Clears all connections and target sequence
             */
            codebyart_reset() {
                this.connections = [];
                this.targetSequence = [];
                this.pulsePhase = 0;
                console.log('ConnectionManager reset');
            }
        }
        
        // ===== END CONNECTION MANAGER CLASS =====
        
        // ===== PARTICLE SYSTEM CLASS =====
        
        /**
         * codebyart_Particle - Represents a single particle for visual effects
         * Used for celebration animations and connection effects
         */
        class codebyart_Particle {
            constructor() {
                // Position
                this.x = 0;
                this.y = 0;
                
                // Velocity
                this.vx = 0;
                this.vy = 0;
                
                // Acceleration (gravity)
                this.ax = 0;
                this.ay = 0;
                
                // Visual properties
                this.size = 3;
                this.color = { r: 255, g: 255, b: 255 };
                this.alpha = 1;
                
                // Lifetime
                this.life = 1; // 0 to 1
                this.decay = 0.01; // How fast it fades
                
                // State
                this.active = false;
                
                // Animation
                this.rotation = 0;
                this.rotationSpeed = 0;
            }
            
            /**
             * Initialize particle with starting parameters
             * @param {number} x - Starting X position
             * @param {number} y - Starting Y position
             * @param {number} vx - X velocity
             * @param {number} vy - Y velocity
             * @param {Object} options - Additional options (color, size, decay, etc.)
             */
            codebyart_init(x, y, vx, vy, options = {}) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                
                // Apply options
                this.ax = options.ax || 0;
                this.ay = options.ay || 0.1; // Default gravity
                this.size = options.size || 3;
                this.color = options.color || { r: 255, g: 255, b: 255 };
                this.alpha = options.alpha || 1;
                this.life = 1;
                this.decay = options.decay || 0.01;
                this.rotation = options.rotation || 0;
                this.rotationSpeed = options.rotationSpeed || 0;
                
                this.active = true;
            }
            
            /**
             * Update particle physics and lifetime
             * @param {number} deltaTime - Time elapsed in milliseconds
             */
            codebyart_update(deltaTime) {
                if (!this.active) return;
                
                // Convert deltaTime to seconds for physics
                const dt = deltaTime / 1000;
                
                // Update velocity with acceleration
                this.vx += this.ax * dt * 60;
                this.vy += this.ay * dt * 60;
                
                // Update position with velocity
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                
                // Update rotation
                this.rotation += this.rotationSpeed * dt * 60;
                
                // Update lifetime
                this.life -= this.decay * dt * 60;
                this.alpha = this.life;
                
                // Deactivate if life is depleted
                if (this.life <= 0) {
                    this.active = false;
                }
            }
            
            /**
             * Render the particle
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             */
            codebyart_render(ctx) {
                if (!this.active || this.alpha <= 0) return;
                
                ctx.save();
                
                // Apply rotation if needed
                if (this.rotation !== 0) {
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.translate(-this.x, -this.y);
                }
                
                // Draw particle with glow
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 2
                );
                
                gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.alpha})`);
                gradient.addColorStop(0.5, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.alpha * 0.5})`);
                gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw bright center
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            /**
             * Reset particle to inactive state
             */
            codebyart_reset() {
                this.active = false;
                this.life = 0;
            }
        }
        
        /**
         * codebyart_ParticleSystem - Manages particle pool and emissions
         * Uses object pooling for performance optimization
         */
        class codebyart_ParticleSystem {
            constructor(maxParticles = 50) {
                this.maxParticles = maxParticles;
                this.particles = [];
                
                // Initialize particle pool
                for (let i = 0; i < this.maxParticles; i++) {
                    this.particles.push(new codebyart_Particle());
                }
                
                console.log(`ParticleSystem initialized with ${this.maxParticles} particles`);
            }
            
            /**
             * Get an inactive particle from the pool
             * @returns {codebyart_Particle|null} Inactive particle or null if pool is full
             */
            codebyart_getParticle() {
                for (let particle of this.particles) {
                    if (!particle.active) {
                        return particle;
                    }
                }
                return null; // Pool is full
            }
            
            /**
             * Emit particles from a specific position
             * @param {number} x - X position
             * @param {number} y - Y position
             * @param {number} count - Number of particles to emit
             * @param {Object} options - Particle options
             */
            codebyart_emit(x, y, count, options = {}) {
                const emitted = Math.min(count, this.maxParticles);
                
                for (let i = 0; i < emitted; i++) {
                    const particle = this.codebyart_getParticle();
                    if (!particle) break; // Pool is full
                    
                    // Random velocity
                    const angle = Math.random() * Math.PI * 2;
                    const speed = options.speed || (Math.random() * 3 + 1);
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    // Initialize particle
                    particle.codebyart_init(x, y, vx, vy, {
                        size: options.size || (Math.random() * 2 + 2),
                        color: options.color || { r: 100, g: 200, b: 255 },
                        decay: options.decay || 0.015,
                        ay: options.gravity !== undefined ? options.gravity : 0.1,
                        rotationSpeed: options.rotationSpeed || (Math.random() * 0.1 - 0.05)
                    });
                }
            }
            
            /**
             * Emit celebration particles (for level completion)
             * Creates a burst of colorful particles
             * @param {number} x - X position
             * @param {number} y - Y position
             */
            codebyart_emitCelebration(x, y) {
                const colors = [
                    { r: 255, g: 220, b: 100 }, // Gold
                    { r: 100, g: 255, b: 150 }, // Green
                    { r: 100, g: 200, b: 255 }, // Blue
                    { r: 255, g: 150, b: 200 }, // Pink
                    { r: 200, g: 150, b: 255 }  // Purple
                ];
                
                // Emit multiple bursts
                for (let burst = 0; burst < 3; burst++) {
                    setTimeout(() => {
                        for (let i = 0; i < 15; i++) {
                            const particle = this.codebyart_getParticle();
                            if (!particle) break;
                            
                            const angle = (Math.PI * 2 * i) / 15 + (Math.random() * 0.3);
                            const speed = Math.random() * 4 + 3;
                            const vx = Math.cos(angle) * speed;
                            const vy = Math.sin(angle) * speed;
                            
                            const color = colors[Math.floor(Math.random() * colors.length)];
                            
                            particle.codebyart_init(x, y, vx, vy, {
                                size: Math.random() * 3 + 3,
                                color: color,
                                decay: 0.012,
                                ay: 0.15,
                                rotationSpeed: Math.random() * 0.2 - 0.1
                            });
                        }
                    }, burst * 150);
                }
            }
            
            /**
             * Emit particles for successful connection
             * Creates a small burst along the connection line
             * @param {number} x - X position
             * @param {number} y - Y position
             */
            codebyart_emitConnection(x, y) {
                const count = 8;
                const color = { r: 100, g: 255, b: 150 }; // Green for success
                
                for (let i = 0; i < count; i++) {
                    const particle = this.codebyart_getParticle();
                    if (!particle) break;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 2 + 1;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    particle.codebyart_init(x, y, vx, vy, {
                        size: Math.random() * 2 + 1.5,
                        color: color,
                        decay: 0.02,
                        ay: 0.05,
                        rotationSpeed: Math.random() * 0.15 - 0.075
                    });
                }
            }
            
            /**
             * Update all active particles
             * @param {number} deltaTime - Time elapsed in milliseconds
             */
            codebyart_update(deltaTime) {
                for (let particle of this.particles) {
                    if (particle.active) {
                        particle.codebyart_update(deltaTime);
                    }
                }
            }
            
            /**
             * Render all active particles
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             */
            codebyart_render(ctx) {
                for (let particle of this.particles) {
                    if (particle.active) {
                        particle.codebyart_render(ctx);
                    }
                }
            }
            
            /**
             * Get count of active particles
             * @returns {number} Number of active particles
             */
            codebyart_getActiveCount() {
                return this.particles.filter(p => p.active).length;
            }
            
            /**
             * Clear all particles
             */
            codebyart_clear() {
                for (let particle of this.particles) {
                    particle.codebyart_reset();
                }
            }
        }
        
        // ===== END PARTICLE SYSTEM CLASS =====
        
        // ===== LEVEL MANAGER CLASS =====
        
        /**
         * codebyart_LevelManager - Manages constellation levels and progression
         * Handles level loading, star positioning, validation, and star rating calculation
         */
        class codebyart_LevelManager {
            constructor(canvasWidth, canvasHeight) {
                // Canvas dimensions for star positioning
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                
                // Current level data
                this.currentLevel = null;
                this.currentLevelNumber = 0;
                
                // All constellation data
                this.constellationData = codebyart_CONSTELLATION_DATA;
                
                // Level progression tracking
                this.unlockedLevels = [1]; // Level 1 is always unlocked
                this.maxLevel = this.constellationData.length;
                
                console.log(`LevelManager initialized with ${this.maxLevel} levels`);
            }
            
            /**
             * Load a level by number
             * @param {number} levelNumber - Level number (1-15)
             * @returns {Object|null} Level data object or null if invalid
             */
            codebyart_loadLevel(levelNumber) {
                // Validate level number
                if (levelNumber < 1 || levelNumber > this.maxLevel) {
                    console.error(`Invalid level number: ${levelNumber}. Must be between 1 and ${this.maxLevel}`);
                    return null;
                }
                
                // Find the level data (array is 0-indexed, levels are 1-indexed)
                const levelData = this.constellationData.find(level => level.id === levelNumber);
                
                if (!levelData) {
                    console.error(`Level ${levelNumber} not found in constellation data`);
                    return null;
                }
                
                // Store current level
                this.currentLevel = levelData;
                this.currentLevelNumber = levelNumber;
                
                console.log(`Level ${levelNumber} loaded: ${levelData.name} (${levelData.difficulty})`);
                console.log(`  Stars: ${levelData.stars.length}`);
                console.log(`  Connections: ${levelData.connections.length}`);
                console.log(`  Hints available: ${levelData.hints}`);
                
                return levelData;
            }
            
            /**
             * Get the current level data
             * @returns {Object|null} Current level data or null if no level loaded
             */
            codebyart_getCurrentLevel() {
                if (!this.currentLevel) {
                    console.warn('No level currently loaded');
                    return null;
                }
                
                return this.currentLevel;
            }
            
            /**
             * Get current level number
             * @returns {number} Current level number (0 if no level loaded)
             */
            codebyart_getCurrentLevelNumber() {
                return this.currentLevelNumber;
            }
            
            /**
             * Convert normalized star positions (0-1) to canvas coordinates
             * Applies padding to keep stars away from edges
             * @param {number} padding - Padding in pixels from canvas edges (default: 50)
             * @returns {Array} Array of star positions with canvas coordinates
             */
            codebyart_getStarPositions(padding = 50) {
                if (!this.currentLevel) {
                    console.warn('No level loaded, cannot get star positions');
                    return [];
                }
                
                // Calculate usable area (with padding)
                const usableWidth = this.canvasWidth - (padding * 2);
                const usableHeight = this.canvasHeight - (padding * 2);
                
                // Convert normalized positions to canvas coordinates
                const positions = this.currentLevel.stars.map(star => {
                    return {
                        id: star.id,
                        x: padding + (star.x * usableWidth),
                        y: padding + (star.y * usableHeight)
                    };
                });
                
                return positions;
            }
            
            /**
             * Get the target connection sequence for validation
             * @returns {Array} Array of target connections [{from, to}, ...]
             */
            codebyart_getTargetSequence() {
                if (!this.currentLevel) {
                    console.warn('No level loaded, cannot get target sequence');
                    return [];
                }
                
                return this.currentLevel.connections;
            }
            
            /**
             * Calculate star rating based on accuracy and hints used
             * @param {number} accuracy - Accuracy percentage (0-100)
             * @param {number} hintsUsed - Number of hints used
             * @returns {number} Star rating (1-3)
             */
            codebyart_calculateStarRating(accuracy, hintsUsed) {
                // Validate inputs
                accuracy = Math.max(0, Math.min(100, accuracy));
                hintsUsed = Math.max(0, hintsUsed);
                
                // Perfect accuracy (100%) with no hints = 3 stars
                if (accuracy === 100 && hintsUsed === 0) {
                    return 3;
                }
                
                // Perfect accuracy with 1 hint = 2 stars
                if (accuracy === 100 && hintsUsed === 1) {
                    return 2;
                }
                
                // Perfect accuracy with 2+ hints = 1 star
                if (accuracy === 100 && hintsUsed >= 2) {
                    return 1;
                }
                
                // Less than perfect accuracy
                // 90-99% accuracy with no hints = 2 stars
                if (accuracy >= 90 && hintsUsed === 0) {
                    return 2;
                }
                
                // 80-99% accuracy with hints, or 90-99% with 1 hint = 1 star
                if (accuracy >= 80) {
                    return 1;
                }
                
                // Below 80% accuracy = 1 star (minimum)
                return 1;
            }
            
            /**
             * Unlock a level for play
             * @param {number} levelNumber - Level number to unlock
             * @returns {boolean} True if level was unlocked
             */
            codebyart_unlockLevel(levelNumber) {
                // Validate level number
                if (levelNumber < 1 || levelNumber > this.maxLevel) {
                    console.warn(`Cannot unlock invalid level: ${levelNumber}`);
                    return false;
                }
                
                // Check if already unlocked
                if (this.unlockedLevels.includes(levelNumber)) {
                    console.log(`Level ${levelNumber} is already unlocked`);
                    return true;
                }
                
                // Unlock the level
                this.unlockedLevels.push(levelNumber);
                this.unlockedLevels.sort((a, b) => a - b);
                
                console.log(`Level ${levelNumber} unlocked!`);
                return true;
            }
            
            /**
             * Check if a level is unlocked
             * @param {number} levelNumber - Level number to check
             * @returns {boolean} True if level is unlocked
             */
            codebyart_isLevelUnlocked(levelNumber) {
                return this.unlockedLevels.includes(levelNumber);
            }
            
            /**
             * Get all unlocked level numbers
             * @returns {Array} Array of unlocked level numbers
             */
            codebyart_getUnlockedLevels() {
                return [...this.unlockedLevels]; // Return a copy
            }
            
            /**
             * Handle level completion and unlock next level
             * @param {number} stars - Star rating achieved (1-3)
             * @param {number} time - Completion time in seconds
             * @param {number} hintsUsed - Number of hints used
             * @returns {Object} Completion result with next level info
             */
            codebyart_completeLevel(stars, time, hintsUsed) {
                if (!this.currentLevel) {
                    console.warn('No level loaded, cannot complete level');
                    return {
                        success: false,
                        message: 'No level loaded'
                    };
                }
                
                const completedLevel = this.currentLevelNumber;
                const nextLevel = completedLevel + 1;
                
                // Unlock next level if it exists
                let nextLevelUnlocked = false;
                if (nextLevel <= this.maxLevel) {
                    nextLevelUnlocked = this.codebyart_unlockLevel(nextLevel);
                }
                
                // Check if this was the last level
                const isLastLevel = completedLevel === this.maxLevel;
                
                console.log(`Level ${completedLevel} completed!`);
                console.log(`  Stars: ${stars}/3`);
                console.log(`  Time: ${time.toFixed(1)}s`);
                console.log(`  Hints used: ${hintsUsed}`);
                
                return {
                    success: true,
                    completedLevel: completedLevel,
                    stars: stars,
                    time: time,
                    hintsUsed: hintsUsed,
                    nextLevel: isLastLevel ? null : nextLevel,
                    nextLevelUnlocked: nextLevelUnlocked,
                    isLastLevel: isLastLevel,
                    message: isLastLevel 
                        ? 'Congratulations! You completed all levels!' 
                        : `Level ${completedLevel} complete! Level ${nextLevel} unlocked!`
                };
            }
            
            /**
             * Get level info by number without loading it
             * @param {number} levelNumber - Level number (1-15)
             * @returns {Object|null} Level info or null if invalid
             */
            codebyart_getLevelInfo(levelNumber) {
                if (levelNumber < 1 || levelNumber > this.maxLevel) {
                    return null;
                }
                
                const levelData = this.constellationData.find(level => level.id === levelNumber);
                
                if (!levelData) {
                    return null;
                }
                
                return {
                    id: levelData.id,
                    name: levelData.name,
                    commonName: levelData.commonName,
                    difficulty: levelData.difficulty,
                    starCount: levelData.stars.length,
                    connectionCount: levelData.connections.length,
                    description: levelData.description,
                    hints: levelData.hints,
                    isUnlocked: this.codebyart_isLevelUnlocked(levelNumber)
                };
            }
            
            /**
             * Get all levels info for level selection menu
             * @returns {Array} Array of level info objects
             */
            codebyart_getAllLevelsInfo() {
                return this.constellationData.map(level => ({
                    id: level.id,
                    name: level.name,
                    commonName: level.commonName,
                    difficulty: level.difficulty,
                    starCount: level.stars.length,
                    connectionCount: level.connections.length,
                    isUnlocked: this.codebyart_isLevelUnlocked(level.id)
                }));
            }
            
            /**
             * Get levels by difficulty
             * @param {string} difficulty - Difficulty level ('easy', 'medium', 'advanced')
             * @returns {Array} Array of level info objects
             */
            codebyart_getLevelsByDifficulty(difficulty) {
                return this.constellationData
                    .filter(level => level.difficulty === difficulty)
                    .map(level => ({
                        id: level.id,
                        name: level.name,
                        commonName: level.commonName,
                        difficulty: level.difficulty,
                        starCount: level.stars.length,
                        connectionCount: level.connections.length,
                        isUnlocked: this.codebyart_isLevelUnlocked(level.id)
                    }));
            }
            
            /**
             * Update canvas dimensions (for responsive resize)
             * Recalculates star positions if a level is loaded
             * @param {number} width - New canvas width
             * @param {number} height - New canvas height
             */
            codebyart_updateCanvasDimensions(width, height) {
                this.canvasWidth = width;
                this.canvasHeight = height;
                
                console.log(`LevelManager canvas dimensions updated: ${width}x${height}`);
            }
            
            /**
             * Reset level manager to initial state
             * Clears current level and resets unlocked levels
             */
            codebyart_reset() {
                this.currentLevel = null;
                this.currentLevelNumber = 0;
                this.unlockedLevels = [1]; // Reset to only level 1 unlocked
                
                console.log('LevelManager reset to initial state');
            }
            
            /**
             * Load unlocked levels from progress data
             * @param {Array} completedLevels - Array of completed level numbers
             */
            codebyart_loadProgressData(completedLevels) {
                if (!Array.isArray(completedLevels)) {
                    console.warn('Invalid progress data provided to LevelManager');
                    return;
                }
                
                // Always unlock level 1
                this.unlockedLevels = [1];
                
                // Unlock all completed levels and their next levels
                completedLevels.forEach(levelNum => {
                    if (levelNum >= 1 && levelNum <= this.maxLevel) {
                        // Unlock the completed level
                        if (!this.unlockedLevels.includes(levelNum)) {
                            this.unlockedLevels.push(levelNum);
                        }
                        
                        // Unlock the next level
                        const nextLevel = levelNum + 1;
                        if (nextLevel <= this.maxLevel && !this.unlockedLevels.includes(nextLevel)) {
                            this.unlockedLevels.push(nextLevel);
                        }
                    }
                });
                
                // Sort unlocked levels
                this.unlockedLevels.sort((a, b) => a - b);
                
                console.log(`Progress loaded: ${this.unlockedLevels.length} levels unlocked`);
                console.log(`Unlocked levels: ${this.unlockedLevels.join(', ')}`);
            }
            
            /**
             * Get the maximum number of levels
             * @returns {number} Total number of levels
             */
            codebyart_getMaxLevel() {
                return this.maxLevel;
            }
            
            /**
             * Get constellation description for current level
             * @returns {string} Description text or empty string
             */
            codebyart_getDescription() {
                if (!this.currentLevel) {
                    return '';
                }
                
                return this.currentLevel.description || '';
            }
            
            /**
             * Get available hints for current level
             * @returns {number} Number of hints available
             */
            codebyart_getAvailableHints() {
                if (!this.currentLevel) {
                    return 0;
                }
                
                return this.currentLevel.hints || 0;
            }
            
            /**
             * Get difficulty of current level
             * @returns {string} Difficulty level or empty string
             */
            codebyart_getDifficulty() {
                if (!this.currentLevel) {
                    return '';
                }
                
                return this.currentLevel.difficulty || '';
            }
            
            /**
             * Get constellation name for current level
             * @returns {string} Constellation name or empty string
             */
            codebyart_getName() {
                if (!this.currentLevel) {
                    return '';
                }
                
                return this.currentLevel.name || '';
            }
            
            /**
             * Get common name for current level
             * @returns {string} Common name or empty string
             */
            codebyart_getCommonName() {
                if (!this.currentLevel) {
                    return '';
                }
                
                return this.currentLevel.commonName || '';
            }
        }
        
        // ===== END LEVEL MANAGER CLASS =====
        
        // ===== INPUT HANDLER CLASS =====
        
        /**
         * codebyart_InputHandler - Handles all user input (mouse, touch, keyboard)
         * Normalizes input across devices and manages UI button interactions
         */
        class codebyart_InputHandler {
            constructor(canvas, game) {
                // References
                this.canvas = canvas;
                this.game = game;
                
                // Input state tracking
                this.isMouseDown = false;
                this.isTouchActive = false;
                this.lastInputTime = 0;
                this.debounceDelay = 50; // milliseconds to prevent input spam
                
                // Current input position
                this.currentX = -1;
                this.currentY = -1;
                
                // Hover tracking
                this.hoveredStarId = null;
                
                // UI button definitions (will be set by game)
                this.uiButtons = [];
                
                // Bind event handlers to maintain 'this' context
                this.boundHandleMouseDown = this.codebyart_handleMouseDown.bind(this);
                this.boundHandleMouseMove = this.codebyart_handleMouseMove.bind(this);
                this.boundHandleMouseUp = this.codebyart_handleMouseUp.bind(this);
                this.boundHandleTouchStart = this.codebyart_handleTouchStart.bind(this);
                this.boundHandleTouchMove = this.codebyart_handleTouchMove.bind(this);
                this.boundHandleTouchEnd = this.codebyart_handleTouchEnd.bind(this);
                
                // Initialize event listeners
                this.codebyart_init();
            }
            
            /**
             * Initialize event listeners
             */
            codebyart_init() {
                if (!this.canvas) {
                    console.error('InputHandler: Canvas not provided');
                    return;
                }
                
                // Mouse events
                this.canvas.addEventListener('mousedown', this.boundHandleMouseDown);
                this.canvas.addEventListener('mousemove', this.boundHandleMouseMove);
                this.canvas.addEventListener('mouseup', this.boundHandleMouseUp);
                this.canvas.addEventListener('mouseleave', this.codebyart_handleMouseLeave.bind(this));
                
                // Touch events
                this.canvas.addEventListener('touchstart', this.boundHandleTouchStart, { passive: false });
                this.canvas.addEventListener('touchmove', this.boundHandleTouchMove, { passive: false });
                this.canvas.addEventListener('touchend', this.boundHandleTouchEnd, { passive: false });
                this.canvas.addEventListener('touchcancel', this.codebyart_handleTouchCancel.bind(this), { passive: false });
                
                console.log('InputHandler initialized');
            }
            
            /**
             * Handle mouse down event
             * @param {MouseEvent} event - Mouse event
             */
            codebyart_handleMouseDown(event) {
                // Check debounce
                if (!this.codebyart_checkDebounce()) {
                    return;
                }
                
                this.isMouseDown = true;
                
                // Get canvas coordinates
                const coords = this.codebyart_getCanvasCoordinates(event.clientX, event.clientY);
                this.currentX = coords.x;
                this.currentY = coords.y;
                
                // Check for UI button clicks first
                if (this.codebyart_checkUIButtons(coords.x, coords.y)) {
                    return; // Button was clicked, don't process star selection
                }
                
                // Notify game of mouse down event
                if (this.game && typeof this.game.codebyart_onInputDown === 'function') {
                    this.game.codebyart_onInputDown(coords.x, coords.y, 'mouse');
                }
            }
            
            /**
             * Handle mouse move event
             * @param {MouseEvent} event - Mouse event
             */
            codebyart_handleMouseMove(event) {
                // Get canvas coordinates
                const coords = this.codebyart_getCanvasCoordinates(event.clientX, event.clientY);
                this.currentX = coords.x;
                this.currentY = coords.y;
                
                // Check for button hover (desktop only)
                this.codebyart_checkButtonHover(coords.x, coords.y);
                
                // Notify game of mouse move event
                if (this.game && typeof this.game.codebyart_onInputMove === 'function') {
                    this.game.codebyart_onInputMove(coords.x, coords.y, this.isMouseDown, 'mouse');
                }
            }
            
            /**
             * Handle mouse up event
             * @param {MouseEvent} event - Mouse event
             */
            codebyart_handleMouseUp(event) {
                this.isMouseDown = false;
                
                // Get canvas coordinates
                const coords = this.codebyart_getCanvasCoordinates(event.clientX, event.clientY);
                
                // Notify game of mouse up event
                if (this.game && typeof this.game.codebyart_onInputUp === 'function') {
                    this.game.codebyart_onInputUp(coords.x, coords.y, 'mouse');
                }
            }
            
            /**
             * Handle mouse leave event
             * @param {MouseEvent} event - Mouse event
             */
            codebyart_handleMouseLeave(event) {
                this.isMouseDown = false;
                this.currentX = -1;
                this.currentY = -1;
                this.hoveredStarId = null;
                
                // Notify game that mouse left canvas
                if (this.game && typeof this.game.codebyart_onInputLeave === 'function') {
                    this.game.codebyart_onInputLeave('mouse');
                }
            }
            
            /**
             * Handle touch start event
             * @param {TouchEvent} event - Touch event
             */
            codebyart_handleTouchStart(event) {
                // Prevent default scrolling during gameplay
                event.preventDefault();
                
                // Check debounce
                if (!this.codebyart_checkDebounce()) {
                    return;
                }
                
                if (event.touches.length === 0) return;
                
                this.isTouchActive = true;
                
                // Get first touch point
                const touch = event.touches[0];
                const coords = this.codebyart_getCanvasCoordinates(touch.clientX, touch.clientY);
                this.currentX = coords.x;
                this.currentY = coords.y;
                
                // Check for UI button clicks first
                if (this.codebyart_checkUIButtons(coords.x, coords.y)) {
                    return; // Button was clicked, don't process star selection
                }
                
                // Notify game of touch start event
                if (this.game && typeof this.game.codebyart_onInputDown === 'function') {
                    this.game.codebyart_onInputDown(coords.x, coords.y, 'touch');
                }
            }
            
            /**
             * Handle touch move event
             * @param {TouchEvent} event - Touch event
             */
            codebyart_handleTouchMove(event) {
                // Prevent default scrolling during gameplay
                event.preventDefault();
                
                if (event.touches.length === 0) return;
                
                // Get first touch point
                const touch = event.touches[0];
                const coords = this.codebyart_getCanvasCoordinates(touch.clientX, touch.clientY);
                this.currentX = coords.x;
                this.currentY = coords.y;
                
                // Notify game of touch move event
                if (this.game && typeof this.game.codebyart_onInputMove === 'function') {
                    this.game.codebyart_onInputMove(coords.x, coords.y, this.isTouchActive, 'touch');
                }
            }
            
            /**
             * Handle touch end event
             * @param {TouchEvent} event - Touch event
             */
            codebyart_handleTouchEnd(event) {
                // Prevent default behavior
                event.preventDefault();
                
                this.isTouchActive = false;
                
                // Get coordinates from changedTouches (touches that ended)
                if (event.changedTouches.length > 0) {
                    const touch = event.changedTouches[0];
                    const coords = this.codebyart_getCanvasCoordinates(touch.clientX, touch.clientY);
                    
                    // Notify game of touch end event
                    if (this.game && typeof this.game.codebyart_onInputUp === 'function') {
                        this.game.codebyart_onInputUp(coords.x, coords.y, 'touch');
                    }
                }
                
                // Reset position if no more touches
                if (event.touches.length === 0) {
                    this.currentX = -1;
                    this.currentY = -1;
                }
            }
            
            /**
             * Handle touch cancel event
             * @param {TouchEvent} event - Touch event
             */
            codebyart_handleTouchCancel(event) {
                // Prevent default behavior
                event.preventDefault();
                
                this.isTouchActive = false;
                this.currentX = -1;
                this.currentY = -1;
                
                // Notify game that touch was cancelled
                if (this.game && typeof this.game.codebyart_onInputLeave === 'function') {
                    this.game.codebyart_onInputLeave('touch');
                }
            }
            
            /**
             * Get canvas coordinates from client coordinates
             * Handles DPI scaling and canvas positioning
             * @param {number} clientX - Client X coordinate
             * @param {number} clientY - Client Y coordinate
             * @returns {Object} Object with x and y canvas coordinates
             */
            codebyart_getCanvasCoordinates(clientX, clientY) {
                if (!this.canvas) {
                    console.error('InputHandler: Canvas not available for coordinate transformation');
                    return { x: 0, y: 0 };
                }
                
                try {
                    // Validate input coordinates
                    if (typeof clientX !== 'number' || typeof clientY !== 'number' || 
                        !isFinite(clientX) || !isFinite(clientY)) {
                        console.warn(`Invalid client coordinates: x=${clientX}, y=${clientY}`);
                        return { x: 0, y: 0 };
                    }
                    
                    // Get canvas bounding rectangle
                    const rect = this.canvas.getBoundingClientRect();
                    
                    // Calculate position relative to canvas
                    let x = clientX - rect.left;
                    let y = clientY - rect.top;
                    
                    // Account for DPI scaling
                    // Canvas internal size vs displayed size
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    
                    // Scale coordinates to match canvas internal coordinates
                    x *= scaleX;
                    y *= scaleY;
                    
                    // Validate coordinates are within canvas bounds
                    // Clamp to ensure they stay within valid range
                    x = Math.max(0, Math.min(this.canvas.width, x));
                    y = Math.max(0, Math.min(this.canvas.height, y));
                    
                    return { x, y };
                } catch (e) {
                    console.error('Error transforming canvas coordinates:', e);
                    return { x: 0, y: 0 };
                }
            }
            
            /**
             * Check if enough time has passed since last input (debouncing)
             * Prevents input spam
             * @returns {boolean} True if input should be processed
             */
            codebyart_checkDebounce() {
                const currentTime = performance.now();
                const timeSinceLastInput = currentTime - this.lastInputTime;
                
                if (timeSinceLastInput < this.debounceDelay) {
                    return false; // Too soon, ignore input
                }
                
                this.lastInputTime = currentTime;
                return true;
            }
            
            /**
             * Check if a UI button was clicked
             * @param {number} x - Canvas X coordinate
             * @param {number} y - Canvas Y coordinate
             * @returns {boolean} True if a button was clicked
             */
            codebyart_checkUIButtons(x, y) {
                if (!this.uiButtons || this.uiButtons.length === 0) {
                    return false;
                }
                
                // Check each button
                for (let button of this.uiButtons) {
                    if (!button.visible) continue;
                    
                    // Check if click is within button bounds
                    if (x >= button.x && x <= button.x + button.width &&
                        y >= button.y && y <= button.y + button.height) {
                        
                        // Set pressed state for animation (100ms duration)
                        if (this.game) {
                            this.game.pressedButton = button.id;
                            setTimeout(() => {
                                if (this.game) {
                                    this.game.pressedButton = null;
                                }
                            }, 100); // 100ms for press animation as per requirements
                        }
                        
                        // Button was clicked, trigger callback
                        if (typeof button.onClick === 'function') {
                            button.onClick();
                            console.log(`UI button clicked: ${button.id}`);
                        }
                        
                        return true;
                    }
                }
                
                return false;
            }
            
            /**
             * Register UI buttons for click detection
             * @param {Array} buttons - Array of button objects with {id, x, y, width, height, onClick, visible}
             */
            codebyart_registerUIButtons(buttons) {
                this.uiButtons = buttons || [];
                console.log(`Registered ${this.uiButtons.length} UI buttons`);
            }
            
            /**
             * Add a single UI button
             * @param {Object} button - Button object with {id, x, y, width, height, onClick, visible}
             */
            codebyart_addUIButton(button) {
                if (!button || !button.id) {
                    console.warn('Invalid button object');
                    return;
                }
                
                // Remove existing button with same id
                this.uiButtons = this.uiButtons.filter(b => b.id !== button.id);
                
                // Add new button
                this.uiButtons.push(button);
                console.log(`UI button added: ${button.id}`);
            }
            
            /**
             * Remove a UI button by id
             * @param {string} buttonId - Button ID to remove
             */
            codebyart_removeUIButton(buttonId) {
                const initialLength = this.uiButtons.length;
                this.uiButtons = this.uiButtons.filter(b => b.id !== buttonId);
                
                if (this.uiButtons.length < initialLength) {
                    console.log(`UI button removed: ${buttonId}`);
                }
            }
            
            /**
             * Update UI button positions (for responsive layout)
             * @param {Array} buttons - Updated button array
             */
            codebyart_updateUIButtons(buttons) {
                this.uiButtons = buttons || [];
            }
            
            /**
             * Check if mouse is hovering over a UI button
             * Updates game state with hovered button ID
             * @param {number} x - Canvas X coordinate
             * @param {number} y - Canvas Y coordinate
             */
            codebyart_checkButtonHover(x, y) {
                if (!this.uiButtons || this.uiButtons.length === 0) {
                    // No buttons, clear hover state
                    if (this.game && this.game.hoveredButton) {
                        this.game.hoveredButton = null;
                    }
                    return;
                }
                
                let hoveredButtonId = null;
                
                // Check each button
                for (let button of this.uiButtons) {
                    if (!button.visible) continue;
                    
                    // Check if mouse is within button bounds
                    if (x >= button.x && x <= button.x + button.width &&
                        y >= button.y && y <= button.y + button.height) {
                        hoveredButtonId = button.id;
                        break;
                    }
                }
                
                // Update game state with hovered button
                if (this.game) {
                    this.game.hoveredButton = hoveredButtonId;
                }
            }
            
            /**
             * Get current input position
             * @returns {Object} Object with x and y coordinates, or null if no active input
             */
            codebyart_getCurrentPosition() {
                if (this.currentX < 0 || this.currentY < 0) {
                    return null;
                }
                
                return { x: this.currentX, y: this.currentY };
            }
            
            /**
             * Check if input is currently active (mouse down or touch active)
             * @returns {boolean} True if input is active
             */
            codebyart_isInputActive() {
                return this.isMouseDown || this.isTouchActive;
            }
            
            /**
             * Set the game reference
             * @param {Object} game - Game object with input callback methods
             */
            codebyart_setGame(game) {
                this.game = game;
                console.log('InputHandler: Game reference set');
            }
            
            /**
             * Set debounce delay
             * @param {number} delay - Delay in milliseconds
             */
            codebyart_setDebounceDelay(delay) {
                this.debounceDelay = Math.max(0, delay);
                console.log(`InputHandler: Debounce delay set to ${this.debounceDelay}ms`);
            }
            
            /**
             * Reset input state
             * Clears all active input tracking
             */
            codebyart_reset() {
                this.isMouseDown = false;
                this.isTouchActive = false;
                this.currentX = -1;
                this.currentY = -1;
                this.hoveredStarId = null;
                this.lastInputTime = 0;
                console.log('InputHandler: State reset');
            }
            
            /**
             * Cleanup and remove event listeners
             * Should be called when destroying the game
             */
            codebyart_destroy() {
                if (!this.canvas) return;
                
                // Remove mouse event listeners
                this.canvas.removeEventListener('mousedown', this.boundHandleMouseDown);
                this.canvas.removeEventListener('mousemove', this.boundHandleMouseMove);
                this.canvas.removeEventListener('mouseup', this.boundHandleMouseUp);
                
                // Remove touch event listeners
                this.canvas.removeEventListener('touchstart', this.boundHandleTouchStart);
                this.canvas.removeEventListener('touchmove', this.boundHandleTouchMove);
                this.canvas.removeEventListener('touchend', this.boundHandleTouchEnd);
                
                console.log('InputHandler: Event listeners removed');
            }
        }
        
        // ===== END INPUT HANDLER CLASS =====
        
        // ===== RENDERER CLASS =====
        
        /**
         * codebyart_Renderer - Handles all rendering operations for the game
         * Manages background, starfield, stars, connections, UI, and overlays
         */
        class codebyart_Renderer {
            constructor(ctx, canvas) {
                // Canvas references
                this.ctx = ctx;
                this.canvas = canvas;
                
                // Background starfield properties
                this.backgroundStars = [];
                this.numBackgroundStars = 150; // 100-200 stars for rich starfield
                this.codebyart_initializeStarfield();
                
                // Animation properties
                this.twinklePhase = 0;
                this.twinkleSpeed = 0.001; // Radians per millisecond
                
                // Nebula animation properties
                this.nebulaPhase = 0;
                this.nebulaSpeed = 0.0001; // Very slow animation for subtle effect
                this.nebulaClouds = [];
                this.codebyart_initializeNebulae();
                
                // Cosmic dust particle properties
                this.cosmicDust = [];
                this.numDustParticles = 25; // 20-30 particles for performance
                this.codebyart_initializeCosmicDust();
                
                // UI properties
                this.uiPadding = 15;
                this.buttonSize = 44; // Minimum touch target size
                this.buttonGap = 10;
                
                // Device detection and layout management
                this.deviceType = this.codebyart_detectDeviceType();
                this.orientation = this.codebyart_detectOrientation();
                this.scaleFactor = this.codebyart_calculateScaleFactor();
                
                // Font sizes (responsive based on device)
                this.titleFontSize = this.codebyart_getResponsiveFontSize(24);
                this.textFontSize = this.codebyart_getResponsiveFontSize(16);
                this.smallTextFontSize = this.codebyart_getResponsiveFontSize(14);
                
                // Performance optimization: cache background gradient
                this.cachedBackgroundGradient = null;
                this.cachedDepthGradient = null;
                this.cachedAccentGradient = null;
                this.lastCanvasWidth = 0;
                this.lastCanvasHeight = 0;
                
                // Dirty region tracking for optimized rendering
                this.dirtyRegions = [];
                this.fullRedrawNeeded = true;
                
                console.log('Renderer initialized with performance optimizations');
            }
            
            /**
             * Initialize background starfield with random positions
             * Creates 150 twinkling stars for rich atmosphere
             * Stars animate opacity (0.3 to 1.0) and size (1px to 2px)
             */
            codebyart_initializeStarfield() {
                this.backgroundStars = [];
                
                for (let i = 0; i < this.numBackgroundStars; i++) {
                    this.backgroundStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        baseSize: Math.random() * 1 + 1, // 1px to 2px base size
                        size: Math.random() * 1 + 1,
                        twinkleOffset: Math.random() * Math.PI * 2,
                        twinkleSpeed: Math.random() * 0.8 + 0.4, // Varied animation speeds
                        sizeVariation: Math.random() * 0.5 + 0.5 // How much size changes
                    });
                }
            }
            
            /**
             * Initialize nebula cloud effects
             * Creates 3-4 large nebula clouds with different colors
             */
            codebyart_initializeNebulae() {
                this.nebulaClouds = [];
                
                // Nebula color palette: purple, blue, and magenta tones
                const nebulaColors = [
                    { r: 45, g: 27, b: 105 },   // Purple #2d1b69
                    { r: 30, g: 58, b: 95 },    // Blue #1e3a5f
                    { r: 74, g: 25, b: 66 },    // Magenta #4a1942
                    { r: 35, g: 20, b: 80 }     // Deep purple
                ];
                
                // Create 3-4 nebula clouds
                const numClouds = 3 + Math.floor(Math.random() * 2);
                
                for (let i = 0; i < numClouds; i++) {
                    const color = nebulaColors[i % nebulaColors.length];
                    
                    this.nebulaClouds.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radiusX: (Math.random() * 200 + 150) * (this.canvas.width / 1920), // Scale with canvas
                        radiusY: (Math.random() * 150 + 100) * (this.canvas.height / 1080),
                        rotation: Math.random() * Math.PI * 2,
                        color: color,
                        baseOpacity: Math.random() * 0.15 + 0.1, // 0.1 to 0.25
                        animationOffset: Math.random() * Math.PI * 2,
                        animationSpeed: Math.random() * 0.5 + 0.5
                    });
                }
            }
            
            /**
             * Initialize cosmic dust particle system
             * Creates 25 subtle particles for atmospheric depth
             * Particles drift slowly across the screen
             */
            codebyart_initializeCosmicDust() {
                this.cosmicDust = [];
                
                for (let i = 0; i < this.numDustParticles; i++) {
                    this.cosmicDust.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 0.5, // 0.5 to 2.5 pixels
                        opacity: Math.random() * 0.15 + 0.05, // 0.05 to 0.2 (very subtle)
                        velocityX: (Math.random() - 0.5) * 0.02, // Slow horizontal drift
                        velocityY: (Math.random() - 0.5) * 0.02, // Slow vertical drift
                        twinkleOffset: Math.random() * Math.PI * 2,
                        twinkleSpeed: Math.random() * 0.3 + 0.2
                    });
                }
            }
            
            /**
             * Detect device type based on screen size and capabilities
             * @returns {string} Device type: 'mobile', 'tablet', or 'desktop'
             */
            codebyart_detectDeviceType() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                
                // Mobile: max 480px width
                if (width <= 480) {
                    return 'mobile';
                }
                
                // Tablet: 481px to 1024px
                if (width <= 1024 && isTouchDevice) {
                    return 'tablet';
                }
                
                // Desktop: 1025px and above, or non-touch device
                return 'desktop';
            }
            
            /**
             * Detect current orientation
             * @returns {string} Orientation: 'portrait' or 'landscape'
             */
            codebyart_detectOrientation() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                return width < height ? 'portrait' : 'landscape';
            }
            
            /**
             * Calculate scale factor based on device and orientation
             * @returns {number} Scale factor for UI elements
             */
            codebyart_calculateScaleFactor() {
                const baseWidth = 1920;
                const baseHeight = 1080;
                const currentWidth = this.canvas.width;
                const currentHeight = this.canvas.height;
                
                // Calculate scale based on smaller dimension to ensure everything fits
                const scaleX = currentWidth / baseWidth;
                const scaleY = currentHeight / baseHeight;
                
                return Math.min(scaleX, scaleY);
            }
            
            /**
             * Get responsive font size based on device type and orientation
             * @param {number} baseFontSize - Base font size in pixels
             * @returns {number} Adjusted font size
             */
            codebyart_getResponsiveFontSize(baseFontSize) {
                let fontSize = baseFontSize;
                
                // Apply device-specific font size adjustments
                if (this.deviceType === 'mobile') {
                    if (this.orientation === 'portrait') {
                        // Mobile portrait: reduce by 20%
                        fontSize *= 0.8;
                    } else {
                        // Mobile landscape: reduce by 10%
                        fontSize *= 0.9;
                    }
                } else if (this.deviceType === 'tablet') {
                    // Tablet: standard font sizes
                    fontSize *= 1.0;
                } else {
                    // Desktop: standard or slightly larger
                    if (this.canvas.width >= 1920) {
                        fontSize *= 1.1;
                    }
                }
                
                // Apply scale factor
                fontSize *= this.scaleFactor;
                
                // Ensure minimum readable size
                return Math.max(10, Math.round(fontSize));
            }
            
            /**
             * Update layout based on device type and orientation
             * Called when orientation changes or window resizes
             */
            codebyart_updateLayout() {
                // Re-detect device type and orientation
                this.deviceType = this.codebyart_detectDeviceType();
                this.orientation = this.codebyart_detectOrientation();
                this.scaleFactor = this.codebyart_calculateScaleFactor();
                
                // Update font sizes
                this.titleFontSize = this.codebyart_getResponsiveFontSize(24);
                this.textFontSize = this.codebyart_getResponsiveFontSize(16);
                this.smallTextFontSize = this.codebyart_getResponsiveFontSize(14);
                
                // Reinitialize background elements for new canvas size
                this.codebyart_initializeStarfield();
                this.codebyart_initializeNebulae();
                this.codebyart_initializeCosmicDust();
                
                // Clear cached gradients to force recreation
                this.cachedBackgroundGradient = null;
                this.cachedDepthGradient = null;
                this.cachedAccentGradient = null;
                
                console.log(`Layout updated: ${this.deviceType} ${this.orientation}, scale: ${this.scaleFactor.toFixed(2)}`);
            }
            
            /**
             * Render enhanced deep space gradient background with multiple layers
             * Creates realistic space environment with depth
             * Optimized with gradient caching to reduce allocations
             */
            codebyart_renderBackground() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                // Check if we need to recreate the gradients (canvas size changed)
                if (!this.cachedBackgroundGradient || 
                    this.lastCanvasWidth !== canvas.width || 
                    this.lastCanvasHeight !== canvas.height) {
                    
                    // Layer 1: Deep space base - radial gradient from center
                    this.cachedBackgroundGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.8
                    );
                    
                    // Deep blacks and dark blues for realistic space
                    this.cachedBackgroundGradient.addColorStop(0, '#0a0e27');  // Dark blue center
                    this.cachedBackgroundGradient.addColorStop(0.3, '#1a1f3a'); // Medium dark blue
                    this.cachedBackgroundGradient.addColorStop(0.7, '#0d0f1f'); // Very dark blue
                    this.cachedBackgroundGradient.addColorStop(1, '#000000');   // Pure black edges
                    
                    // Layer 2: Secondary depth gradient - offset radial for dimension
                    this.cachedDepthGradient = ctx.createRadialGradient(
                        canvas.width * 0.3, canvas.height * 0.3, 0,
                        canvas.width * 0.3, canvas.height * 0.3, Math.max(canvas.width, canvas.height) * 0.6
                    );
                    
                    this.cachedDepthGradient.addColorStop(0, 'rgba(26, 31, 58, 0.4)');  // Subtle blue glow
                    this.cachedDepthGradient.addColorStop(0.5, 'rgba(10, 14, 39, 0.2)');
                    this.cachedDepthGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');       // Fade to transparent
                    
                    // Layer 3: Accent gradient - bottom right for depth
                    this.cachedAccentGradient = ctx.createRadialGradient(
                        canvas.width * 0.8, canvas.height * 0.8, 0,
                        canvas.width * 0.8, canvas.height * 0.8, Math.max(canvas.width, canvas.height) * 0.5
                    );
                    
                    this.cachedAccentGradient.addColorStop(0, 'rgba(13, 15, 31, 0.3)');
                    this.cachedAccentGradient.addColorStop(0.6, 'rgba(10, 14, 39, 0.15)');
                    this.cachedAccentGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    // Update cached dimensions
                    this.lastCanvasWidth = canvas.width;
                    this.lastCanvasHeight = canvas.height;
                }
                
                // Render all gradient layers
                ctx.save();
                
                // Layer 1: Base deep space gradient
                ctx.fillStyle = this.cachedBackgroundGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Layer 2: Depth gradient for dimension
                ctx.fillStyle = this.cachedDepthGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Layer 3: Accent gradient for additional depth
                ctx.fillStyle = this.cachedAccentGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.restore();
            }
            
            /**
             * Render nebula cloud effects with subtle opacity animation
             * Creates atmospheric depth with semi-transparent layered clouds
             * @param {number} deltaTime - Time elapsed since last update in milliseconds
             */
            codebyart_renderNebulaEffects(deltaTime) {
                const ctx = this.ctx;
                
                // Update nebula animation phase
                this.nebulaPhase += this.nebulaSpeed * deltaTime;
                if (this.nebulaPhase > Math.PI * 2) {
                    this.nebulaPhase -= Math.PI * 2;
                }
                
                ctx.save();
                
                // Render each nebula cloud
                for (let i = 0; i < this.nebulaClouds.length; i++) {
                    const nebula = this.nebulaClouds[i];
                    
                    // Calculate animated opacity (0.1 to 0.3 over 30s cycle)
                    const animPhase = this.nebulaPhase * nebula.animationSpeed + nebula.animationOffset;
                    const opacityVariation = Math.sin(animPhase) * 0.1; // 0.1 variation
                    const currentOpacity = Math.max(0.1, Math.min(0.3, nebula.baseOpacity + opacityVariation));
                    
                    // Create radial gradient for nebula cloud
                    const gradient = ctx.createRadialGradient(
                        nebula.x, nebula.y, 0,
                        nebula.x, nebula.y, Math.max(nebula.radiusX, nebula.radiusY)
                    );
                    
                    // Multi-stop gradient for realistic cloud effect
                    gradient.addColorStop(0, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, ${currentOpacity})`);
                    gradient.addColorStop(0.3, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, ${currentOpacity * 0.7})`);
                    gradient.addColorStop(0.6, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, ${currentOpacity * 0.4})`);
                    gradient.addColorStop(1, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, 0)`);
                    
                    // Apply rotation and draw elliptical nebula
                    ctx.save();
                    ctx.translate(nebula.x, nebula.y);
                    ctx.rotate(nebula.rotation);
                    ctx.scale(nebula.radiusX / nebula.radiusY, 1);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, nebula.radiusY, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                ctx.restore();
            }
            
            /**
             * Render animated twinkling starfield background
             * 150 stars with individual twinkle animations
             * Animates opacity (0.3 to 1.0) and size (1px to 2px) with random timing
             * Optimized with for loops and reduced gradient allocations
             * @param {number} deltaTime - Time elapsed since last update in milliseconds
             */
            codebyart_renderStarfield(deltaTime) {
                const ctx = this.ctx;
                
                // Update twinkle phase
                this.twinklePhase += this.twinkleSpeed * deltaTime;
                if (this.twinklePhase > Math.PI * 2) {
                    this.twinklePhase -= Math.PI * 2;
                }
                
                ctx.save();
                
                // Render each background star (use for loop for better performance)
                const starCount = this.backgroundStars.length;
                for (let i = 0; i < starCount; i++) {
                    const star = this.backgroundStars[i];
                    
                    // Calculate twinkle intensity for opacity (0.3 to 1.0)
                    const twinklePhase = this.twinklePhase * star.twinkleSpeed + star.twinkleOffset;
                    const twinkle = Math.sin(twinklePhase) * 0.5 + 0.5; // 0 to 1
                    const alpha = 0.3 + (twinkle * 0.7); // 0.3 to 1.0 range
                    
                    // Calculate size animation (1px to 2px)
                    const sizePhase = twinklePhase * 0.8; // Slightly different phase for size
                    const sizeTwinkle = Math.sin(sizePhase) * 0.5 + 0.5; // 0 to 1
                    const currentSize = star.baseSize + (sizeTwinkle * star.sizeVariation * 0.5);
                    
                    // Validate values
                    const validAlpha = isNaN(alpha) ? 0.5 : Math.max(0.3, Math.min(1.0, alpha));
                    const validSize = isNaN(currentSize) ? 1.5 : Math.max(1, Math.min(2, currentSize));
                    
                    // Draw star with subtle glow
                    const gradient = ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, validSize * 2
                    );
                    
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${validAlpha})`);
                    gradient.addColorStop(0.4, `rgba(220, 230, 255, ${validAlpha * 0.6})`);
                    gradient.addColorStop(1, `rgba(200, 220, 255, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, validSize * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw bright center point
                    ctx.fillStyle = `rgba(255, 255, 255, ${validAlpha})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, validSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            /**
             * Render cosmic dust particle effects
             * Subtle particles that drift slowly for atmospheric depth
             * @param {number} deltaTime - Time elapsed since last update in milliseconds
             */
            codebyart_renderCosmicDust(deltaTime) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.save();
                
                // Update and render each dust particle
                for (let i = 0; i < this.cosmicDust.length; i++) {
                    const particle = this.cosmicDust[i];
                    
                    // Update position with slow drift
                    particle.x += particle.velocityX * deltaTime * 0.01;
                    particle.y += particle.velocityY * deltaTime * 0.01;
                    
                    // Wrap around screen edges
                    if (particle.x < -10) particle.x = canvas.width + 10;
                    if (particle.x > canvas.width + 10) particle.x = -10;
                    if (particle.y < -10) particle.y = canvas.height + 10;
                    if (particle.y > canvas.height + 10) particle.y = -10;
                    
                    // Calculate subtle opacity variation
                    const twinklePhase = this.twinklePhase * particle.twinkleSpeed + particle.twinkleOffset;
                    const twinkle = Math.sin(twinklePhase) * 0.5 + 0.5;
                    const currentOpacity = particle.opacity * (0.5 + twinkle * 0.5);
                    
                    // Draw particle with soft glow
                    const gradient = ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size * 3
                    );
                    
                    gradient.addColorStop(0, `rgba(200, 210, 230, ${currentOpacity})`);
                    gradient.addColorStop(0.5, `rgba(180, 190, 220, ${currentOpacity * 0.5})`);
                    gradient.addColorStop(1, `rgba(160, 180, 210, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            /**
             * Render all star nodes
             * Optimized with for loop for better performance
             * @param {Array} stars - Array of StarNode objects
             */
            codebyart_renderStars(stars) {
                if (!stars || stars.length === 0) return;
                
                // Use for loop for better performance
                const starCount = stars.length;
                for (let i = 0; i < starCount; i++) {
                    stars[i].codebyart_render(this.ctx);
                }
            }
            
            /**
             * Render connection lines between stars
             * @param {Array} connections - Array of connection line data
             * @param {Array} stars - Array of StarNode objects
             */
            codebyart_renderConnections(connections, stars) {
                if (!connections || connections.length === 0) return;
                if (!stars || stars.length === 0) return;
                
                const ctx = this.ctx;
                
                ctx.save();
                
                connections.forEach(line => {
                    // Calculate animated end point for drawing animation
                    const progress = line.animationProgress || 1;
                    const currentToX = line.fromX + (line.toX - line.fromX) * progress;
                    const currentToY = line.fromY + (line.toY - line.fromY) * progress;
                    
                    // Determine line color based on correctness
                    let color = { r: 100, g: 200, b: 255 }; // Default blue
                    if (line.isCorrect !== undefined) {
                        color = line.isCorrect 
                            ? { r: 100, g: 255, b: 150 } // Green for correct
                            : { r: 255, g: 100, b: 100 }; // Red for incorrect
                    }
                    
                    // Validate color values
                    const r = Math.floor(color?.r) || 100;
                    const g = Math.floor(color?.g) || 200;
                    const b = Math.floor(color?.b) || 255;
                    
                    // Draw outer glow
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                    ctx.lineWidth = 9;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.fromX, line.fromY);
                    ctx.lineTo(currentToX, currentToY);
                    ctx.stroke();
                    
                    // Draw gradient line
                    const gradient = ctx.createLinearGradient(
                        line.fromX, line.fromY,
                        currentToX, currentToY
                    );
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
                    gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 1)`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.8)`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.fromX, line.fromY);
                    ctx.lineTo(currentToX, currentToY);
                    ctx.stroke();
                    
                    // Draw bright center line
                    ctx.strokeStyle = `rgba(255, 255, 255, 0.6)`;
                    ctx.lineWidth = 1;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.fromX, line.fromY);
                    ctx.lineTo(currentToX, currentToY);
                    ctx.stroke();
                });
                
                ctx.restore();
            }
            
            /**
             * Render UI elements (score, level, timer, buttons) with glassmorphism
             * @param {Object} gameState - Current game state object
             */
            codebyart_renderUI(gameState) {
                if (!gameState) return;
                
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.save();
                
                // Calculate responsive font sizes
                const scale = Math.min(canvas.width / 800, canvas.height / 600);
                this.titleFontSize = Math.max(18, 24 * scale);
                this.textFontSize = Math.max(14, 16 * scale);
                this.smallTextFontSize = Math.max(12, 14 * scale);
                
                // ===== GLASSMORPHISM HUD PANEL (TOP CENTER) =====
                const hudPadding = 16;
                const hudHeight = this.titleFontSize + this.smallTextFontSize + hudPadding * 2 + 10;
                const hudWidth = Math.min(500, canvas.width * 0.6);
                const hudX = (canvas.width - hudWidth) / 2;
                const hudY = this.uiPadding;
                
                // Draw glass panel background for main HUD
                this.codebyart_drawGlassPanel(ctx, hudX, hudY, hudWidth, hudHeight, 12);
                
                // Render level info (centered in HUD panel)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = `bold ${this.titleFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
                
                const levelText = `Level ${gameState.level}: ${gameState.levelName}`;
                ctx.fillText(levelText, canvas.width / 2, hudY + hudPadding);
                
                // Render difficulty (below level name)
                ctx.font = `500 ${this.smallTextFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.fillStyle = this.codebyart_getDifficultyColor(gameState.difficulty);
                const difficultyText = gameState.difficulty ? gameState.difficulty.toUpperCase() : '';
                ctx.fillText(difficultyText, canvas.width / 2, hudY + hudPadding + this.titleFontSize + 5);
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // ===== GLASSMORPHISM STATS PANEL (TOP RIGHT) =====
                const statsWidth = Math.min(200, canvas.width * 0.25);
                const statsHeight = (this.textFontSize + 8) * 3 + hudPadding * 2;
                const statsX = canvas.width - statsWidth - this.uiPadding;
                const statsY = this.uiPadding;
                
                // Draw glass panel background for stats
                this.codebyart_drawGlassPanel(ctx, statsX, statsY, statsWidth, statsHeight, 12);
                
                // Render hints remaining
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.font = `500 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 3;
                
                const hintsText = ` Hints: ${gameState.hintsRemaining || 0}/3`;
                const hintsTextX = statsX + hudPadding;
                let hintsTextY = statsY + hudPadding;
                
                // Apply hint icon scale animation (200ms pulse when hint is used)
                if (gameState.hintIconScale && gameState.hintIconScale !== 1) {
                    ctx.save();
                    ctx.translate(hintsTextX, hintsTextY);
                    ctx.scale(gameState.hintIconScale, gameState.hintIconScale);
                    ctx.translate(-hintsTextX, -hintsTextY);
                }
                
                if (gameState.hintLevel > 0) {
                    ctx.fillText(hintsText, hintsTextX, hintsTextY);
                    ctx.font = `400 ${this.smallTextFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.fillStyle = 'rgba(255, 200, 80, 0.8)';
                    ctx.fillText(`(Level ${gameState.hintLevel})`, hintsTextX, hintsTextY + this.textFontSize + 2);
                    hintsTextY += this.textFontSize + this.smallTextFontSize + 4;
                } else {
                    ctx.fillText(hintsText, hintsTextX, hintsTextY);
                    hintsTextY += this.textFontSize + 8;
                }
                
                // Restore context if hint icon scale was applied
                if (gameState.hintIconScale && gameState.hintIconScale !== 1) {
                    ctx.restore();
                }
                
                // Render undo count
                if (gameState.undoRemaining !== undefined && gameState.undoLimit !== undefined) {
                    ctx.fillStyle = 'rgba(150, 200, 255, 0.95)';
                    ctx.font = `500 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    const undoText = ` Undo: ${gameState.undoRemaining}/${gameState.undoLimit}`;
                    ctx.fillText(undoText, hintsTextX, hintsTextY);
                    hintsTextY += this.textFontSize + 8;
                }
                
                // Render timer
                if (gameState.time !== undefined) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.font = `500 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    const timerText = ` Time: ${gameState.time.toFixed(1)}s`;
                    ctx.fillText(timerText, hintsTextX, hintsTextY);
                }
                
                ctx.shadowBlur = 0;
                
                // ===== GLASSMORPHISM BEST SCORES PANEL (TOP LEFT) =====
                if (gameState.bestTime !== undefined && gameState.bestTime !== null) {
                    const bestWidth = Math.min(160, canvas.width * 0.2);
                    const bestHeight = (this.smallTextFontSize + 5) * 3 + hudPadding * 2;
                    const bestX = this.uiPadding;
                    const bestY = this.uiPadding;
                    
                    // Draw glass panel background for best scores
                    this.codebyart_drawGlassPanel(ctx, bestX, bestY, bestWidth, bestHeight, 12);
                    
                    ctx.textAlign = 'left';
                    ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                    ctx.font = `700 ${this.smallTextFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 3;
                    
                    let bestTextY = bestY + hudPadding;
                    ctx.fillText('Best:', bestX + hudPadding, bestTextY);
                    bestTextY += this.smallTextFontSize + 5;
                    
                    // Best stars
                    if (gameState.bestStars !== undefined && gameState.bestStars !== null) {
                        ctx.font = `500 ${this.smallTextFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                        ctx.fillStyle = 'rgba(255, 220, 100, 0.9)';
                        const starText = ` ${gameState.bestStars}/3`;
                        ctx.fillText(starText, bestX + hudPadding, bestTextY);
                        bestTextY += this.smallTextFontSize + 5;
                    }
                    
                    // Best time
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    const bestTimeText = ` ${gameState.bestTime.toFixed(1)}s`;
                    ctx.fillText(bestTimeText, bestX + hudPadding, bestTextY);
                    
                    ctx.shadowBlur = 0;
                }
                
                // Render FPS counter (bottom left) - Performance monitoring
                if (gameState.fps !== undefined) {
                    const fpsWidth = 100;
                    const fpsHeight = this.smallTextFontSize + hudPadding * 2;
                    const fpsX = this.uiPadding;
                    const fpsY = canvas.height - fpsHeight - this.uiPadding;
                    
                    // Draw small glass panel for FPS
                    this.codebyart_drawGlassPanel(ctx, fpsX, fpsY, fpsWidth, fpsHeight, 8);
                    
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    
                    // Color code FPS: green (60+), yellow (30-59), red (<30)
                    let fpsColor = 'rgba(100, 255, 100, 0.9)'; // Green
                    if (gameState.fps < 30) {
                        fpsColor = 'rgba(255, 100, 100, 0.9)'; // Red
                    } else if (gameState.fps < 60) {
                        fpsColor = 'rgba(255, 220, 100, 0.9)'; // Yellow
                    }
                    
                    ctx.fillStyle = fpsColor;
                    ctx.font = `500 ${this.smallTextFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, monospace`;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 3;
                    ctx.fillText(`FPS: ${gameState.fps}`, fpsX + hudPadding, fpsY + fpsHeight / 2);
                    ctx.shadowBlur = 0;
                }
                
                // Render UI buttons (bottom)
                this.codebyart_renderUIButtons(gameState);
                
                ctx.restore();
            }
            
            /**
             * Draw a glassmorphism panel on canvas
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} x - X position
             * @param {number} y - Y position
             * @param {number} width - Panel width
             * @param {number} height - Panel height
             * @param {number} radius - Border radius
             */
            codebyart_drawGlassPanel(ctx, x, y, width, height, radius) {
                ctx.save();
                
                // Background with semi-transparency
                ctx.fillStyle = 'rgba(10, 14, 39, 0.6)';
                this.codebyart_fillRoundedRect(ctx, x, y, width, height, radius);
                
                // Border with subtle glow
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = 1;
                this.codebyart_strokeRoundedRect(ctx, x, y, width, height, radius);
                
                // Inner highlight for depth
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                this.codebyart_strokeRoundedRect(ctx, x + 1, y + 1, width - 2, height - 2, radius - 1);
                
                // Subtle shadow for depth
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 16;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0)';
                this.codebyart_strokeRoundedRect(ctx, x, y, width, height, radius);
                
                ctx.restore();
            }
            
            /**
             * Draw a stronger glassmorphism panel for modals
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} x - X position
             * @param {number} y - Y position
             * @param {number} width - Panel width
             * @param {number} height - Panel height
             * @param {number} radius - Border radius
             */
            codebyart_drawGlassPanelStrong(ctx, x, y, width, height, radius) {
                ctx.save();
                
                // Background with stronger semi-transparency
                ctx.fillStyle = 'rgba(10, 14, 39, 0.75)';
                this.codebyart_fillRoundedRect(ctx, x, y, width, height, radius);
                
                // Border with stronger glow
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                this.codebyart_strokeRoundedRect(ctx, x, y, width, height, radius);
                
                // Inner highlight for depth
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                this.codebyart_strokeRoundedRect(ctx, x + 2, y + 2, width - 4, height - 4, radius - 2);
                
                // Stronger shadow for depth
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 24;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 8;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0)';
                this.codebyart_strokeRoundedRect(ctx, x, y, width, height, radius);
                
                ctx.restore();
            }
            
            /**
             * Render UI buttons (restart, hint, mute, pause, menu)
             * Responsive buttons with touch-friendly size and hover states
             * @param {Object} gameState - Current game state
             */
            codebyart_renderUIButtons(gameState) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                // Calculate responsive button size (minimum 44px for touch targets)
                const scale = Math.min(canvas.width / 800, canvas.height / 600);
                const responsiveButtonSize = Math.max(44, Math.min(60, 50 * scale));
                const responsiveButtonGap = Math.max(8, 10 * scale);
                const responsivePadding = Math.max(10, 15 * scale);
                
                // Button positions (bottom center)
                const buttonY = canvas.height - responsiveButtonSize - responsivePadding;
                const totalWidth = (responsiveButtonSize * 6) + (responsiveButtonGap * 5);
                let buttonX = (canvas.width - totalWidth) / 2;
                
                // Store button bounds for click detection
                if (!this.uiButtons) {
                    this.uiButtons = [];
                }
                this.uiButtons = [];
                
                // Button definitions with enhanced styling
                const buttons = [
                    { 
                        id: 'restart', 
                        label: '', 
                        color: 'rgba(100, 150, 255, 0.8)', 
                        hoverColor: 'rgba(120, 170, 255, 0.95)',
                        showBadge: false,
                        tooltip: 'Restart Level'
                    },
                    { 
                        id: 'undo', 
                        label: '', 
                        color: 'rgba(150, 200, 255, 0.8)', 
                        hoverColor: 'rgba(170, 220, 255, 0.95)',
                        showBadge: true, 
                        badgeValue: gameState.undoRemaining || 0,
                        tooltip: 'Undo Last Connection'
                    },
                    { 
                        id: 'hint', 
                        label: '', 
                        color: 'rgba(255, 220, 100, 0.8)', 
                        hoverColor: 'rgba(255, 230, 120, 0.95)',
                        showBadge: true, 
                        badgeValue: gameState.hintsRemaining || 0,
                        tooltip: 'Use Hint'
                    },
                    { 
                        id: 'mute', 
                        label: gameState.isMuted ? '' : '', 
                        color: 'rgba(150, 150, 150, 0.8)', 
                        hoverColor: 'rgba(170, 170, 170, 0.95)',
                        showBadge: false,
                        tooltip: gameState.isMuted ? 'Unmute' : 'Mute'
                    },
                    { 
                        id: 'pause', 
                        label: '', 
                        color: 'rgba(200, 150, 100, 0.8)', 
                        hoverColor: 'rgba(220, 170, 120, 0.95)',
                        showBadge: false,
                        tooltip: 'Pause Game'
                    },
                    { 
                        id: 'menu', 
                        label: '', 
                        color: 'rgba(100, 200, 150, 0.8)', 
                        hoverColor: 'rgba(120, 220, 170, 0.95)',
                        showBadge: false,
                        tooltip: 'Main Menu'
                    }
                ];
                
                buttons.forEach(button => {
                    // Store button bounds for interaction
                    const buttonBounds = {
                        id: button.id,
                        x: buttonX,
                        y: buttonY,
                        width: responsiveButtonSize,
                        height: responsiveButtonSize,
                        enabled: true
                    };
                    
                    // Disable hint button if no hints remaining
                    if (button.id === 'hint' && button.badgeValue === 0) {
                        buttonBounds.enabled = false;
                    }
                    
                    // Disable undo button if no undos remaining
                    if (button.id === 'undo' && button.badgeValue === 0) {
                        buttonBounds.enabled = false;
                    }
                    
                    this.uiButtons.push(buttonBounds);
                    
                    // Check if button is being hovered (set by input handler)
                    const isHovered = gameState.hoveredButton === button.id && buttonBounds.enabled;
                    
                    // Check if button is being pressed (active state)
                    const isPressed = gameState.pressedButton === button.id && buttonBounds.enabled;
                    
                    // ===== 3D BUTTON RENDERING WITH GRADIENTS AND DEPTH =====
                    
                    ctx.save();
                    
                    // Calculate scale and position adjustments for animations
                    // Hover: scale(1.05) - button appears 5% larger
                    // Active: scale(0.95) - button appears 5% smaller (pressed down)
                    let scale = 1.0;
                    let offsetX = 0;
                    let offsetY = 0;
                    
                    if (isPressed) {
                        // Active state: scale down and move down slightly
                        scale = 0.95;
                        offsetY = 2; // Pressed down effect
                    } else if (isHovered) {
                        // Hover state: scale up and lift slightly
                        scale = 1.05;
                        offsetY = -2; // Lifted effect
                    }
                    
                    // Calculate scaled dimensions and centered position
                    const scaledSize = responsiveButtonSize * scale;
                    const scaleOffsetX = (responsiveButtonSize - scaledSize) / 2;
                    const scaleOffsetY = (responsiveButtonSize - scaledSize) / 2;
                    const finalX = buttonX + scaleOffsetX + offsetX;
                    const finalY = buttonY + scaleOffsetY + offsetY;
                    
                    if (buttonBounds.enabled) {
                        // Multi-layer box shadows for depth effect
                        // Adjust shadow based on state
                        if (isPressed) {
                            // Pressed: minimal shadow (button is down)
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                            this.codebyart_fillRoundedRect(ctx, finalX + 1, finalY + 2, scaledSize, scaledSize, 8);
                        } else if (isHovered) {
                            // Hovered: elevated shadow (button is lifted)
                            // Layer 1: Deep shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                            this.codebyart_fillRoundedRect(ctx, finalX + 6, finalY + 12, scaledSize, scaledSize, 8);
                            
                            // Layer 2: Mid shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                            this.codebyart_fillRoundedRect(ctx, finalX + 4, finalY + 8, scaledSize, scaledSize, 8);
                            
                            // Layer 3: Close shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            this.codebyart_fillRoundedRect(ctx, finalX + 2, finalY + 4, scaledSize, scaledSize, 8);
                        } else {
                            // Normal: standard shadow
                            // Layer 1: Deep shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                            this.codebyart_fillRoundedRect(ctx, finalX + 4, finalY + 8, scaledSize, scaledSize, 8);
                            
                            // Layer 2: Mid shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            this.codebyart_fillRoundedRect(ctx, finalX + 2, finalY + 4, scaledSize, scaledSize, 8);
                            
                            // Layer 3: Close shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                            this.codebyart_fillRoundedRect(ctx, finalX + 1, finalY + 2, scaledSize, scaledSize, 8);
                        }
                    }
                    
                    // Determine gradient colors based on button type
                    let gradientStart, gradientEnd;
                    
                    if (!buttonBounds.enabled) {
                        // Disabled: grayscale
                        gradientStart = 'rgba(80, 80, 80, 0.5)';
                        gradientEnd = 'rgba(60, 60, 60, 0.5)';
                    } else if (button.color && button.color.includes('255, 220, 100')) {
                        // Hint button: Primary gradient (indigo to purple)
                        gradientStart = isHovered ? 'rgba(102, 102, 241, 1)' : 'rgba(102, 102, 241, 0.9)';
                        gradientEnd = isHovered ? 'rgba(139, 92, 246, 1)' : 'rgba(139, 92, 246, 0.9)';
                    } else if (button.id === 'menu') {
                        // Menu/Clear Progress: Danger gradient (red to pink)
                        gradientStart = isHovered ? 'rgba(239, 68, 68, 1)' : 'rgba(239, 68, 68, 0.9)';
                        gradientEnd = isHovered ? 'rgba(236, 72, 153, 1)' : 'rgba(236, 72, 153, 0.9)';
                    } else {
                        // Other buttons: Secondary gradient (blue to cyan)
                        gradientStart = isHovered ? 'rgba(59, 130, 246, 1)' : 'rgba(59, 130, 246, 0.9)';
                        gradientEnd = isHovered ? 'rgba(6, 182, 212, 1)' : 'rgba(6, 182, 212, 0.9)';
                    }
                    
                    // Create gradient background (135deg diagonal)
                    const gradient = ctx.createLinearGradient(
                        finalX, 
                        finalY, 
                        finalX + scaledSize, 
                        finalY + scaledSize
                    );
                    gradient.addColorStop(0, gradientStart);
                    gradient.addColorStop(1, gradientEnd);
                    
                    // Draw button background with gradient
                    ctx.fillStyle = gradient;
                    this.codebyart_fillRoundedRect(ctx, finalX, finalY, scaledSize, scaledSize, 8 * scale);
                    
                    // Inset shadow for lighting simulation (top light)
                    ctx.save();
                    ctx.globalCompositeOperation = 'overlay';
                    const insetGradient = ctx.createLinearGradient(
                        finalX, 
                        finalY, 
                        finalX, 
                        finalY + scaledSize
                    );
                    insetGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    insetGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
                    insetGradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
                    ctx.fillStyle = insetGradient;
                    this.codebyart_fillRoundedRect(ctx, finalX, finalY, scaledSize, scaledSize, 8 * scale);
                    ctx.restore();
                    
                    // Draw button border with elevated shadow on hover
                    if (isHovered && !isPressed) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 3;
                        ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                        ctx.shadowBlur = 15;
                    } else {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 0;
                    }
                    this.codebyart_strokeRoundedRect(ctx, finalX, finalY, scaledSize, scaledSize, 8 * scale);
                    
                    ctx.restore();
                    
                    // Draw button label with responsive font size (using scaled position)
                    ctx.fillStyle = buttonBounds.enabled ? 'rgba(255, 255, 255, 0.95)' : 'rgba(150, 150, 150, 0.6)';
                    const labelFontSize = Math.max(18, Math.min(24, 20 * Math.min(canvas.width / 800, canvas.height / 600)));
                    ctx.font = `${labelFontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(button.label, finalX + scaledSize / 2, finalY + scaledSize / 2);
                    
                    // Draw badge for hint counter (using scaled position)
                    if (button.showBadge && button.badgeValue !== undefined) {
                        const badgeScale = Math.min(canvas.width / 800, canvas.height / 600);
                        const badgeSize = Math.max(16, 20 * badgeScale);
                        const badgeX = finalX + scaledSize - badgeSize / 2 - 3;
                        const badgeY = finalY + badgeSize / 2 + 3;
                        
                        // Badge shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.beginPath();
                        ctx.arc(badgeX + 1, badgeY + 1, badgeSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Badge background circle
                        ctx.fillStyle = button.badgeValue > 0 ? 'rgba(255, 100, 100, 0.95)' : 'rgba(100, 100, 100, 0.8)';
                        ctx.beginPath();
                        ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Badge border
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Badge number
                        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                        const badgeFontSize = Math.max(10, 12 * scale);
                        ctx.font = `bold ${badgeFontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(button.badgeValue.toString(), badgeX, badgeY);
                    }
                    
                    // Draw tooltip on hover (desktop only, using scaled position)
                    if (isHovered && !isPressed && button.tooltip && !gameState.isMobile) {
                        const tooltipY = finalY - 35;
                        const tooltipPadding = 8;
                        
                        // Measure tooltip text
                        const tooltipScale = Math.min(canvas.width / 800, canvas.height / 600);
                        ctx.font = `${Math.max(12, 14 * tooltipScale)}px Arial`;
                        const tooltipWidth = ctx.measureText(button.tooltip).width + tooltipPadding * 2;
                        const tooltipX = finalX + scaledSize / 2 - tooltipWidth / 2;
                        
                        // Draw tooltip background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                        this.codebyart_fillRoundedRect(ctx, tooltipX, tooltipY - 20, tooltipWidth, 24, 4);
                        
                        // Draw tooltip border
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 1;
                        this.codebyart_strokeRoundedRect(ctx, tooltipX, tooltipY - 20, tooltipWidth, 24, 4);
                        
                        // Draw tooltip text
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(button.tooltip, finalX + scaledSize / 2, tooltipY - 8);
                    }
                    
                    // Move to next button position
                    buttonX += responsiveButtonSize + responsiveButtonGap;
                });
            }
            
            /**
             * Helper function to draw rounded rectangle (filled)
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} x - X position
             * @param {number} y - Y position
             * @param {number} width - Width
             * @param {number} height - Height
             * @param {number} radius - Corner radius
             */
            codebyart_fillRoundedRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
            }
            
            /**
             * Helper function to draw rounded rectangle (stroke)
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} x - X position
             * @param {number} y - Y position
             * @param {number} width - Width
             * @param {number} height - Height
             * @param {number} radius - Corner radius
             */
            codebyart_strokeRoundedRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.stroke();
            }
            
            /**
             * Get button at specific coordinates (for click/touch detection)
             * @param {number} x - X coordinate
             * @param {number} y - Y coordinate
             * @returns {Object|null} Button object or null if no button at coordinates
             */
            codebyart_getButtonAt(x, y) {
                if (!this.uiButtons) return null;
                
                for (let button of this.uiButtons) {
                    if (x >= button.x && x <= button.x + button.width &&
                        y >= button.y && y <= button.y + button.height &&
                        button.enabled) {
                        return button;
                    }
                }
                
                return null;
            }
            
            /**
             * Check if coordinates are over any UI button
             * @param {number} x - X coordinate
             * @param {number} y - Y coordinate
             * @returns {boolean} True if over a button
             */
            codebyart_isOverButton(x, y) {
                return this.codebyart_getButtonAt(x, y) !== null;
            }
            
            /**
             * Render main menu with level selection grid
             * @param {Object} progress - Player progress data
             */
            codebyart_renderMenu(progress) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.save();
                
                // Calculate responsive font sizes
                const scale = Math.min(canvas.width / 800, canvas.height / 600);
                this.titleFontSize = Math.max(18, 24 * scale);
                this.textFontSize = Math.max(14, 16 * scale);
                this.smallTextFontSize = Math.max(12, 14 * scale);
                
                // Title
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = `bold ${this.titleFontSize + 8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText('Constellation Connect', canvas.width / 2, 30);
                
                // Subtitle
                ctx.font = `${this.textFontSize}px Arial`;
                ctx.fillStyle = 'rgba(200, 220, 255, 0.8)';
                ctx.fillText('Select a Level', canvas.width / 2, 70);
                
                // Level grid (3 columns x 5 rows for 15 levels)
                const cols = 3;
                const rows = 5;
                // Ensure minimum 44px touch target for accessibility
                const buttonSize = Math.max(44, Math.min(80, (canvas.width - 100) / cols));
                const buttonGap = Math.max(8, 15); // Minimum 8px spacing
                const gridWidth = (buttonSize * cols) + (buttonGap * (cols - 1));
                const gridHeight = (buttonSize * rows) + (buttonGap * (rows - 1));
                const startX = (canvas.width - gridWidth) / 2;
                const startY = 120;
                
                // Draw level buttons with 3D styling
                for (let i = 0; i < 15; i++) {
                    const levelNum = i + 1;
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = startX + (col * (buttonSize + buttonGap));
                    const y = startY + (row * (buttonSize + buttonGap));
                    
                    // Check if level is unlocked
                    const isUnlocked = !progress || levelNum === 1 || 
                                      (progress.completedLevels && progress.completedLevels.includes(levelNum - 1));
                    const isCompleted = progress && progress.completedLevels && 
                                       progress.completedLevels.includes(levelNum);
                    
                    ctx.save();
                    
                    // Multi-layer box shadows for 3D depth effect (only for unlocked levels)
                    if (isUnlocked) {
                        // Layer 1: Deep shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.fillRect(x + 3, y + 6, buttonSize, buttonSize);
                        
                        // Layer 2: Mid shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.fillRect(x + 2, y + 3, buttonSize, buttonSize);
                        
                        // Layer 3: Close shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.fillRect(x + 1, y + 1, buttonSize, buttonSize);
                    }
                    
                    // Button gradient background
                    let levelGradient;
                    if (isUnlocked) {
                        levelGradient = ctx.createLinearGradient(x, y, x + buttonSize, y + buttonSize);
                        if (isCompleted) {
                            // Completed: green gradient
                            levelGradient.addColorStop(0, 'rgba(34, 197, 94, 0.8)');
                            levelGradient.addColorStop(1, 'rgba(22, 163, 74, 0.8)');
                        } else {
                            // Unlocked: blue gradient (secondary)
                            levelGradient.addColorStop(0, 'rgba(59, 130, 246, 0.8)');
                            levelGradient.addColorStop(1, 'rgba(6, 182, 212, 0.8)');
                        }
                    } else {
                        // Locked: grayscale
                        levelGradient = ctx.createLinearGradient(x, y, x + buttonSize, y + buttonSize);
                        levelGradient.addColorStop(0, 'rgba(80, 80, 80, 0.5)');
                        levelGradient.addColorStop(1, 'rgba(60, 60, 60, 0.5)');
                    }
                    ctx.fillStyle = levelGradient;
                    ctx.fillRect(x, y, buttonSize, buttonSize);
                    
                    // Inset shadow for lighting simulation (only for unlocked)
                    if (isUnlocked) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'overlay';
                        const levelInsetGradient = ctx.createLinearGradient(x, y, x, y + buttonSize);
                        levelInsetGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                        levelInsetGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
                        levelInsetGradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
                        ctx.fillStyle = levelInsetGradient;
                        ctx.fillRect(x, y, buttonSize, buttonSize);
                        ctx.restore();
                    }
                    
                    // Button border
                    ctx.strokeStyle = isUnlocked ? 'rgba(255, 255, 255, 0.4)' : 'rgba(100, 100, 100, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, buttonSize, buttonSize);
                    
                    ctx.restore();
                    
                    // Level number
                    ctx.fillStyle = isUnlocked ? 'rgba(255, 255, 255, 0.9)' : 'rgba(150, 150, 150, 0.5)';
                    ctx.font = `bold ${this.textFontSize + 4}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(levelNum.toString(), x + buttonSize / 2, y + buttonSize / 2);
                    
                    // Star rating for completed levels
                    if (isCompleted && progress.levelData && progress.levelData[levelNum]) {
                        const stars = progress.levelData[levelNum].stars || 0;
                        const starSize = 8;
                        const starY = y + buttonSize - 15;
                        const starStartX = x + (buttonSize - (stars * 12)) / 2;
                        
                        for (let s = 0; s < stars; s++) {
                            this.codebyart_drawStar(ctx, starStartX + (s * 12) + 6, starY, starSize, true);
                        }
                    }
                    
                    // Lock icon for locked levels
                    if (!isUnlocked) {
                        ctx.font = `${this.textFontSize + 4}px Arial`;
                        ctx.fillText('', x + buttonSize / 2, y + buttonSize / 2 + 20);
                    }
                }
                
                // Progress summary
                if (progress && progress.completedLevels) {
                    const completedCount = progress.completedLevels.length;
                    const totalCount = 15;
                    const progressPercent = Math.round((completedCount / totalCount) * 100);
                    
                    ctx.font = `${this.textFontSize}px Arial`;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.textAlign = 'center';
                    const progressText = `Progress: ${completedCount}/${totalCount} (${progressPercent}%)`;
                    ctx.fillText(progressText, canvas.width / 2, startY + gridHeight + 40);
                }
                
                // Instructions
                ctx.font = `${this.smallTextFontSize}px Arial`;
                ctx.fillStyle = 'rgba(200, 220, 255, 0.7)';
                ctx.fillText('Click a level to start', canvas.width / 2, canvas.height - 30);
                
                // Clear Progress button - positioned in top-right corner with 3D styling
                const clearButtonWidth = 140;
                const clearButtonHeight = 32;
                const clearButtonX = canvas.width - clearButtonWidth - 20;
                const clearButtonY = 20;
                
                // Store button bounds for click detection
                this.clearProgressButton = {
                    x: clearButtonX,
                    y: clearButtonY,
                    width: clearButtonWidth,
                    height: clearButtonHeight
                };
                
                ctx.save();
                
                // Multi-layer box shadows for 3D depth effect
                // Layer 1: Deep shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(clearButtonX + 3, clearButtonY + 6, clearButtonWidth, clearButtonHeight);
                
                // Layer 2: Mid shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(clearButtonX + 2, clearButtonY + 3, clearButtonWidth, clearButtonHeight);
                
                // Layer 3: Close shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(clearButtonX + 1, clearButtonY + 1, clearButtonWidth, clearButtonHeight);
                
                // Danger gradient background (red to pink) - 135deg diagonal
                const clearGradient = ctx.createLinearGradient(
                    clearButtonX, 
                    clearButtonY, 
                    clearButtonX + clearButtonWidth, 
                    clearButtonY + clearButtonHeight
                );
                clearGradient.addColorStop(0, 'rgba(239, 68, 68, 0.9)');
                clearGradient.addColorStop(1, 'rgba(236, 72, 153, 0.9)');
                ctx.fillStyle = clearGradient;
                ctx.fillRect(clearButtonX, clearButtonY, clearButtonWidth, clearButtonHeight);
                
                // Inset shadow for lighting simulation (top light)
                ctx.save();
                ctx.globalCompositeOperation = 'overlay';
                const clearInsetGradient = ctx.createLinearGradient(
                    clearButtonX, 
                    clearButtonY, 
                    clearButtonX, 
                    clearButtonY + clearButtonHeight
                );
                clearInsetGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                clearInsetGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
                clearInsetGradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
                ctx.fillStyle = clearInsetGradient;
                ctx.fillRect(clearButtonX, clearButtonY, clearButtonWidth, clearButtonHeight);
                ctx.restore();
                
                // Button border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.strokeRect(clearButtonX, clearButtonY, clearButtonWidth, clearButtonHeight);
                
                // Button text with shadow
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = `bold ${this.smallTextFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 4;
                ctx.fillText(' Clear Progress', clearButtonX + clearButtonWidth / 2, clearButtonY + clearButtonHeight / 2);
                
                ctx.restore();
                
                ctx.restore();
            }
            
            /**
             * Render tutorial overlay with glassmorphism
             * Shows instructions for first-time players
             */
            codebyart_renderTutorial() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.save();
                
                // Backdrop blur overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Tutorial box
                const boxWidth = Math.min(500, canvas.width - 40);
                const boxHeight = Math.min(400, canvas.height - 40);
                const boxX = (canvas.width - boxWidth) / 2;
                const boxY = (canvas.height - boxHeight) / 2;
                
                // Draw glassmorphism modal background
                this.codebyart_drawGlassPanelStrong(ctx, boxX, boxY, boxWidth, boxHeight, 20);
                
                // Title with text shadow
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = `700 ${this.titleFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
                ctx.fillText('How to Play', canvas.width / 2, boxY + 30);
                ctx.shadowBlur = 0;
                
                // Instructions with improved typography
                ctx.font = `400 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 4;
                
                const instructions = [
                    '1. Click or tap stars to select them',
                    '2. Connect stars in the correct sequence',
                    '3. Form the constellation pattern shown',
                    '4. Use hints if you get stuck (max 3 per level)',
                    '5. Complete all connections to finish the level',
                    '',
                    'Tips:',
                    ' Green lines = correct connections',
                    ' Red lines = incorrect connections',
                    ' Earn 3 stars for perfect completion!'
                ];
                
                let textY = boxY + 80;
                instructions.forEach(line => {
                    if (line === 'Tips:') {
                        ctx.font = `500 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                        ctx.fillStyle = 'rgba(100, 200, 255, 0.95)';
                    } else if (line.startsWith('')) {
                        ctx.font = `400 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                        ctx.fillStyle = 'rgba(200, 220, 255, 0.9)';
                    } else {
                        ctx.font = `400 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    }
                    ctx.fillText(line, boxX + 30, textY);
                    textY += this.textFontSize + 8;
                });
                
                ctx.shadowBlur = 0;
                
                // Click to continue with glow effect
                ctx.font = `700 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(100, 200, 255, 0.95)';
                ctx.shadowColor = 'rgba(100, 200, 255, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText('Click anywhere to start', canvas.width / 2, boxY + boxHeight - 40);
                
                ctx.restore();
            }
            
            /**
             * Render pause overlay with glassmorphism
             * Shows pause menu with resume and quit options
             */
            codebyart_renderPauseOverlay() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.save();
                
                // Backdrop blur overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Pause box
                const boxWidth = Math.min(350, canvas.width - 40);
                const boxHeight = Math.min(250, canvas.height - 40);
                const boxX = (canvas.width - boxWidth) / 2;
                const boxY = (canvas.height - boxHeight) / 2;
                
                // Draw glassmorphism modal background
                this.codebyart_drawGlassPanelStrong(ctx, boxX, boxY, boxWidth, boxHeight, 20);
                
                // Title with text shadow and letter spacing
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = `700 ${this.titleFontSize + 4}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
                ctx.fillText('PAUSED', canvas.width / 2, boxY + 40);
                ctx.shadowBlur = 0;
                
                // Instructions with improved typography
                ctx.font = `400 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.fillStyle = 'rgba(200, 220, 255, 0.9)';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 4;
                ctx.fillText('Press P to resume', canvas.width / 2, boxY + 100);
                ctx.fillText('Press ESC for menu', canvas.width / 2, boxY + 130);
                ctx.fillText('Press R to restart', canvas.width / 2, boxY + 160);
                
                ctx.restore();
            }
            
            /**
             * Render level complete overlay with glassmorphism, star rating and time
             * @param {Object} completionData - Level completion data
             */
            codebyart_renderLevelComplete(completionData) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.save();
                
                // Backdrop blur overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Completion box
                const boxWidth = Math.min(500, canvas.width - 40);
                const boxHeight = Math.min(450, canvas.height - 40);
                const boxX = (canvas.width - boxWidth) / 2;
                const boxY = (canvas.height - boxHeight) / 2;
                
                // Draw glassmorphism modal background
                this.codebyart_drawGlassPanelStrong(ctx, boxX, boxY, boxWidth, boxHeight, 20);
                
                // Title with success color and text shadow
                ctx.fillStyle = 'rgba(100, 255, 150, 0.95)';
                ctx.font = `700 ${this.titleFontSize + 4}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
                ctx.fillText('Level Complete!', canvas.width / 2, boxY + 30);
                ctx.shadowBlur = 0;
                
                // Constellation name with improved typography
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = `500 ${this.textFontSize + 2}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 4;
                ctx.fillText(completionData.levelName || '', canvas.width / 2, boxY + 70);
                ctx.shadowBlur = 0;
                
                // Star rating
                const starSize = 30;
                const starSpacing = 50;
                const starY = boxY + 120;
                const starStartX = (canvas.width - (starSpacing * 2)) / 2;
                
                for (let i = 0; i < 3; i++) {
                    const starX = starStartX + (i * starSpacing);
                    const filled = i < (completionData.stars || 0);
                    
                    this.codebyart_drawStar(ctx, starX, starY, starSize, filled);
                }
                
                // Completion stats with improved typography
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = `400 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 4;
                ctx.fillText(`Time: ${(completionData.time || 0).toFixed(1)}s`, canvas.width / 2, boxY + 180);
                
                // Show "New Best!" if player beat their previous best time (Requirement 6.3)
                if (completionData.isNewBest) {
                    ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                    ctx.font = `700 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.shadowColor = 'rgba(255, 220, 100, 0.5)';
                    ctx.shadowBlur = 10;
                    ctx.fillText(' New Best Time! ', canvas.width / 2, boxY + 205);
                    ctx.shadowBlur = 4;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = `400 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.fillText(`Hints Used: ${completionData.hintsUsed || 0}`, canvas.width / 2, boxY + 230);
                } else {
                    ctx.fillText(`Hints Used: ${completionData.hintsUsed || 0}`, canvas.width / 2, boxY + 205);
                }
                
                ctx.shadowBlur = 0;
                
                // Mythology description with improved typography
                if (completionData.description) {
                    ctx.font = `400 ${this.smallTextFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.fillStyle = 'rgba(200, 220, 255, 0.85)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 3;
                    const description = this.codebyart_wrapText(completionData.description, boxWidth - 60);
                    let descY = boxY + 245;
                    description.slice(0, 3).forEach(line => { // Limit to 3 lines
                        ctx.fillText(line, canvas.width / 2, descY);
                        descY += this.smallTextFontSize + 4;
                    });
                    ctx.shadowBlur = 0;
                }
                
                // Continue prompt with glow effect
                ctx.font = `700 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.fillStyle = 'rgba(100, 200, 255, 0.95)';
                ctx.shadowColor = 'rgba(100, 200, 255, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText('Click to continue', canvas.width / 2, boxY + boxHeight - 30);
                
                ctx.restore();
            }
            
            /**
             * Render game complete screen with glassmorphism
             * Shows congratulations and final statistics
             * @param {Object} progress - Player progress data
             * @param {Object} sessionStats - Current session statistics
             */
            codebyart_renderGameComplete(progress, sessionStats) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.save();
                
                // Backdrop blur overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Completion box
                const boxWidth = Math.min(550, canvas.width - 40);
                const boxHeight = Math.min(500, canvas.height - 40);
                const boxX = (canvas.width - boxWidth) / 2;
                const boxY = (canvas.height - boxHeight) / 2;
                
                // Draw glassmorphism modal background
                this.codebyart_drawGlassPanelStrong(ctx, boxX, boxY, boxWidth, boxHeight, 20);
                
                // Title with golden glow
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.font = `700 ${this.titleFontSize + 8}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.shadowColor = 'rgba(255, 220, 100, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
                ctx.fillText(' Congratulations! ', canvas.width / 2, boxY + 30);
                ctx.shadowBlur = 0;
                
                // Subtitle with improved typography
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = `500 ${this.textFontSize + 2}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 4;
                ctx.fillText('You completed all constellations!', canvas.width / 2, boxY + 80);
                ctx.shadowBlur = 0;
                
                // Overall Statistics (Requirement 6.2, 6.5)
                if (progress && progress.levelData) {
                    let totalStars = 0;
                    let totalTime = 0;
                    
                    Object.values(progress.levelData).forEach(level => {
                        totalStars += level.stars || 0;
                        totalTime += level.bestTime || 0;
                    });
                    
                    const maxStars = 45; // 15 levels * 3 stars
                    const starPercent = Math.round((totalStars / maxStars) * 100);
                    
                    ctx.font = `700 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 4;
                    ctx.fillText('Overall Progress:', canvas.width / 2, boxY + 120);
                    
                    ctx.font = `400 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.fillStyle = 'rgba(200, 220, 255, 0.9)';
                    
                    let statY = boxY + 150;
                    ctx.fillText(`Total Stars: ${totalStars}/${maxStars} (${starPercent}%)`, canvas.width / 2, statY);
                    statY += 25;
                    ctx.fillText(`Total Time: ${totalTime.toFixed(1)}s`, canvas.width / 2, statY);
                    statY += 25;
                    ctx.fillText(`Levels Completed: ${progress.totalLevelsCompleted || 15}/15`, canvas.width / 2, statY);
                    ctx.shadowBlur = 0;
                }
                
                // Session Statistics (Requirement 6.1)
                if (sessionStats && sessionStats.levelsCompleted > 0) {
                    ctx.font = `700 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 4;
                    ctx.fillText('This Session:', canvas.width / 2, boxY + 260);
                    
                    ctx.font = `400 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                    ctx.fillStyle = 'rgba(100, 255, 150, 0.9)';
                    
                    let sessionY = boxY + 290;
                    ctx.fillText(`Levels Completed: ${sessionStats.levelsCompleted}`, canvas.width / 2, sessionY);
                    sessionY += 25;
                    ctx.fillText(`Stars Earned: ${sessionStats.totalStars}`, canvas.width / 2, sessionY);
                    sessionY += 25;
                    ctx.fillText(`Total Time: ${sessionStats.totalTime.toFixed(1)}s`, canvas.width / 2, sessionY);
                    ctx.shadowBlur = 0;
                }
                
                // Achievement message with glow
                ctx.font = `500 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                ctx.shadowColor = 'rgba(255, 220, 100, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText('Master of the Stars!', canvas.width / 2, boxY + 410);
                ctx.shadowBlur = 0;
                
                // Return to menu prompt with glow effect
                ctx.font = `700 ${this.textFontSize}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                ctx.fillStyle = 'rgba(100, 200, 255, 0.95)';
                ctx.shadowColor = 'rgba(100, 200, 255, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText('Click to return to menu', canvas.width / 2, boxY + boxHeight - 30);
                
                ctx.restore();
            }
            
            /**
             * Draw a star icon for rating display
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} x - Center X coordinate
             * @param {number} y - Center Y coordinate
             * @param {number} size - Star size
             * @param {boolean} filled - Whether star is filled or outline
             */
            codebyart_drawStar(ctx, x, y, size, filled) {
                const spikes = 5;
                const outerRadius = size;
                const innerRadius = size * 0.4;
                
                ctx.save();
                ctx.beginPath();
                
                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / spikes - Math.PI / 2;
                    const pointX = x + Math.cos(angle) * radius;
                    const pointY = y + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        ctx.moveTo(pointX, pointY);
                    } else {
                        ctx.lineTo(pointX, pointY);
                    }
                }
                
                ctx.closePath();
                
                if (filled) {
                    // Filled star with gradient
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, outerRadius);
                    gradient.addColorStop(0, 'rgba(255, 220, 100, 1)');
                    gradient.addColorStop(1, 'rgba(255, 180, 50, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Glow effect
                    ctx.shadowColor = 'rgba(255, 220, 100, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Outline star
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            /**
             * Get color for difficulty level
             * @param {string} difficulty - Difficulty level
             * @returns {string} RGBA color string
             */
            codebyart_getDifficultyColor(difficulty) {
                switch (difficulty.toLowerCase()) {
                    case 'easy':
                        return 'rgba(100, 255, 150, 0.9)';
                    case 'medium':
                        return 'rgba(255, 220, 100, 0.9)';
                    case 'advanced':
                        return 'rgba(255, 100, 100, 0.9)';
                    default:
                        return 'rgba(255, 255, 255, 0.9)';
                }
            }
            
            /**
             * Wrap text to fit within a maximum width
             * @param {string} text - Text to wrap
             * @param {number} maxWidth - Maximum width in pixels
             * @returns {Array} Array of text lines
             */
            codebyart_wrapText(text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                const ctx = this.ctx;
                ctx.font = `${this.smallTextFontSize}px Arial`;
                
                words.forEach(word => {
                    const testLine = currentLine + (currentLine ? ' ' : '') + word;
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                });
                
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            /**
             * Update starfield positions on canvas resize
             * Regenerates starfield to match new canvas dimensions
             */
            codebyart_updateCanvasSize() {
                this.codebyart_initializeStarfield();
                console.log('Renderer: Canvas size updated, starfield regenerated');
            }
            
            /**
             * Clear the entire canvas
             */
            codebyart_clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }
        
        // ===== END RENDERER CLASS =====
        
        // ===== CONSTELLATION GAME MAIN CONTROLLER =====
        
        /**
         * codebyart_ConstellationGame - Main game controller
         * Manages game state machine, coordinates all subsystems, and handles game loop
         */
        class codebyart_ConstellationGame {
            constructor(canvasId) {
                // Canvas references
                this.canvas = document.getElementById(canvasId);
                this.ctx = null;
                
                // Game state
                this.state = 'loading'; // loading, menu, tutorial, playing, paused, levelComplete, gameComplete
                this.currentLevel = 1;
                this.selectedStars = [];
                this.hintsRemaining = 3;
                this.hintLevel = 0; // Track hint tier (0=unused, 1=first hint, 2=second hint, 3=show pattern)
                this.hintUsedLevel3 = false; // Flag if level 3 hint used (forfeits score)
                this.levelStartTime = 0;
                this.levelElapsedTime = 0;
                this.isPaused = false;
                
                // Undo system
                this.undoLimit = 3; // Based on difficulty
                this.undoCount = 0; // How many undos used
                this.connectionHistory = []; // Stack of connections for undo
                
                // Subsystems
                this.storageManager = null;
                this.audioManager = null;
                this.levelManager = null;
                this.connectionManager = null;
                this.inputHandler = null;
                this.renderer = null;
                
                // Game entities
                this.stars = [];
                this.backgroundStars = [];
                
                // Animation timing
                this.lastFrameTime = 0;
                this.animationFrameId = null;
                
                // Progress data
                this.progress = null;
                this.settings = null;
                
                // Session tracking (Requirement 6.1)
                this.sessionStartTime = Date.now();
                this.sessionLevelsCompleted = 0;
                this.sessionStats = {
                    levelsCompleted: 0,
                    totalStars: 0,
                    totalTime: 0,
                    hintsUsed: 0
                };
                
                // Current level best scores (Requirement 6.3)
                this.currentLevelBestTime = null;
                this.currentLevelBestStars = null;
                
                // UI state
                this.hoveredButton = null; // ID of currently hovered button (desktop only)
                this.pressedButton = null; // ID of currently pressed button (for active state animation)
                
                // Initialize the game
                this.codebyart_init();
            }
            
            /**
             * Detect if running on mobile device
             * @returns {boolean} True if mobile device
             */
            codebyart_isMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (window.innerWidth <= 768);
            }
            
            /**
             * Initialize canvas, context, and all subsystems
             */
            codebyart_init() {
                console.log('Initializing Constellation Connect Game...');
                
                // Verify canvas exists
                if (!this.canvas) {
                    console.error('Canvas element not found');
                    alert('Game canvas not found. Please refresh the page.');
                    return;
                }
                
                // Get 2D context
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.error('Failed to get canvas context');
                    alert('Your browser does not support HTML5 Canvas. Please use a modern browser.');
                    return;
                }
                
                // Initialize storage manager
                this.storageManager = new codebyart_StorageManager();
                console.log('StorageManager initialized');
                
                // Initialize audio manager
                this.audioManager = new codebyart_AudioManager(this.storageManager);
                console.log('AudioManager initialized');
                
                // Initialize level manager
                this.levelManager = new codebyart_LevelManager(this.canvas.width, this.canvas.height);
                console.log('LevelManager initialized');
                
                // Initialize connection manager
                this.connectionManager = new codebyart_ConnectionManager();
                console.log('ConnectionManager initialized');
                
                // Initialize particle system
                this.particleSystem = new codebyart_ParticleSystem(50); // Max 50 particles
                console.log('ParticleSystem initialized');
                
                // Initialize input handler
                this.inputHandler = new codebyart_InputHandler(this.canvas, this);
                console.log('InputHandler initialized');
                
                // Initialize renderer
                this.renderer = new codebyart_Renderer(this.ctx, this.canvas);
                console.log('Renderer initialized');
                
                // Fade transition properties
                this.fadeAlpha = 0; // 0 = transparent, 1 = opaque
                this.fadeDirection = 0; // -1 = fade out, 0 = no fade, 1 = fade in
                this.fadeSpeed = 0.05; // Fade speed per frame
                this.fadeCallback = null; // Function to call when fade completes
                
                // Screen shake properties (Requirement 7.2)
                this.screenShakeActive = false;
                this.screenShakeProgress = 0; // 0 to 1
                this.screenShakeDuration = 200; // milliseconds
                this.screenShakeIntensity = 5; // pixels
                this.screenShakeOffsetX = 0;
                this.screenShakeOffsetY = 0;
                
                // Score animation properties (Requirement 7.3)
                this.scoreAnimationActive = false;
                this.scoreAnimationProgress = 0; // 0 to 1
                this.scoreAnimationDuration = 300; // milliseconds
                this.scoreAnimationStartValue = 0;
                this.scoreAnimationTargetValue = 0;
                this.scoreAnimationCurrentValue = 0;
                
                // Level transition animation (Requirement 7.3)
                this.levelTransitionActive = false;
                this.levelTransitionProgress = 0; // 0 to 1
                this.levelTransitionDuration = 500; // milliseconds
                this.levelTransitionAlpha = 0;
                
                // Hint icon animation (Requirement 7.3)
                this.hintIconAnimationActive = false;
                this.hintIconAnimationProgress = 0; // 0 to 1
                this.hintIconAnimationDuration = 200; // milliseconds
                this.hintIconScale = 1;
                
                // Load progress and settings
                this.progress = this.storageManager.codebyart_loadProgress();
                this.settings = this.storageManager.codebyart_loadAllSettings();
                console.log('Progress and settings loaded');
                
                // Setup responsive canvas sizing
                this.codebyart_setupResponsiveCanvas();
                
                // Handle window resize and orientation change
                window.addEventListener('resize', () => this.codebyart_handleResize());
                window.addEventListener('orientationchange', () => this.codebyart_handleResize());
                
                // Setup UI button callbacks
                this.codebyart_setupUICallbacks();
                
                // Generate background starfield
                this.codebyart_generateBackgroundStars();
                
                // Always start with tutorial/welcome screen
                this.codebyart_changeState('tutorial');
                
                // Setup canvas click handler for state transitions
                this.codebyart_setupCanvasClickHandler();
                
                // Setup canvas context loss and recovery handlers
                this.codebyart_setupContextLossHandlers();
                
                // Start game loop
                this.codebyart_startGameLoop();
                
                console.log('Game initialization complete!');
                console.log(`Loaded ${codebyart_CONSTELLATION_DATA.length} constellations`);
            }
            
            /**
             * Setup responsive canvas sizing
             */
            codebyart_setupResponsiveCanvas() {
                // Full-screen canvas - use entire viewport
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // Set canvas to full screen
                this.canvas.width = width;
                this.canvas.height = height;
                
                // Update level manager with new dimensions
                if (this.levelManager) {
                    this.levelManager.canvasWidth = width;
                    this.levelManager.canvasHeight = height;
                }
                
                console.log(`Canvas resized to ${width}x${height}`);
            }
            
            /**
             * Handle window resize and orientation change events
             */
            codebyart_handleResize() {
                // Debounce resize events
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.codebyart_setupResponsiveCanvas();
                    
                    // Regenerate background stars for new canvas size
                    this.codebyart_generateBackgroundStars();
                    
                    // Reload current level to reposition stars
                    if (this.state === 'playing' && this.currentLevel) {
                        const starPositions = this.levelManager.codebyart_getStarPositions();
                        this.stars = starPositions.map(pos => 
                            new codebyart_StarNode(pos.x, pos.y, pos.id, pos.size)
                        );
                    }
                    
                    console.log('Resize handled');
                }, 250);
            }
            
            /**
             * Setup UI button callbacks
             * Registers button click handlers with the input handler
             */
            codebyart_setupUICallbacks() {
                // Button callbacks will be registered dynamically during render
                // based on current game state and button positions
                console.log('UI callbacks setup complete');
            }
            
            /**
             * Register UI buttons with input handler
             * Called during render to update button positions and callbacks
             */
            codebyart_registerUIButtons() {
                if (!this.renderer || !this.renderer.uiButtons || !this.inputHandler) {
                    return;
                }
                
                // Get button bounds from renderer
                const buttons = this.renderer.uiButtons.map(button => ({
                    id: button.id,
                    x: button.x,
                    y: button.y,
                    width: button.width,
                    height: button.height,
                    enabled: button.enabled,
                    visible: true,
                    onClick: () => this.codebyart_handleButtonClick(button.id)
                }));
                
                // Register with input handler
                this.inputHandler.codebyart_registerUIButtons(buttons);
            }
            
            /**
             * Handle UI button clicks
             * @param {string} buttonId - ID of the clicked button
             */
            codebyart_handleButtonClick(buttonId) {
                console.log(`Button clicked: ${buttonId}`);
                
                switch (buttonId) {
                    case 'restart':
                        this.codebyart_onRestartClick();
                        break;
                    case 'undo':
                        this.codebyart_onUndoClick();
                        break;
                    case 'hint':
                        this.codebyart_onHintClick();
                        break;
                    case 'mute':
                        this.codebyart_onMuteClick();
                        break;
                    case 'pause':
                        this.codebyart_onPauseClick();
                        break;
                    case 'menu':
                        this.codebyart_onMenuClick();
                        break;
                    default:
                        console.warn(`Unknown button: ${buttonId}`);
                }
            }
            
            /**
             * Handle restart button click
             * Resets the current level
             */
            codebyart_onRestartClick() {
                if (this.state !== 'playing') return;
                
                console.log('Restarting level');
                
                // Play sound
                if (this.audioManager) {
                    this.audioManager.codebyart_playStarSelect();
                }
                
                // Restart current level
                this.codebyart_resetLevel();
            }
            
            /**
             * Handle undo button click
             * Undoes the last connection
             */
            codebyart_onUndoClick() {
                if (this.state !== 'playing') return;
                
                console.log('Undo button clicked');
                
                // Call undo function
                this.codebyart_undoLastConnection();
            }
            
            /**
             * Clear all progress and start fresh
             * Shows confirmation dialog before clearing
             */
            codebyart_clearAllProgress() {
                const confirmed = confirm(
                    ' WARNING: This will delete ALL your progress!\n\n' +
                    'All completed levels, scores, and best times will be permanently deleted.\n\n' +
                    'Are you sure you want to start fresh?'
                );
                
                if (confirmed) {
                    console.log('Clearing all progress...');
                    
                    // Clear all data from storage
                    if (this.storageManager) {
                        this.storageManager.codebyart_clearAllData();
                    }
                    
                    // Reset progress object
                    this.progress = this.storageManager.codebyart_loadProgress();
                    
                    // Reset session stats
                    this.sessionLevelsCompleted = 0;
                    this.sessionStats = {
                        levelsCompleted: 0,
                        totalStars: 0,
                        totalTime: 0,
                        hintsUsed: 0
                    };
                    
                    // Play sound
                    if (this.audioManager) {
                        this.audioManager.codebyart_playStarSelect();
                    }
                    
                    // Return to menu
                    this.codebyart_changeState('menu');
                    
                    console.log('All progress cleared! Starting fresh.');
                    
                    // Show success message
                    setTimeout(() => {
                        alert(' All progress has been cleared!\n\nYou can now start fresh from Level 1.');
                    }, 500);
                } else {
                    console.log('Clear progress cancelled');
                }
            }
            
            /**
             * Handle hint button click
             * Reveals the next correct star connection
             */
            codebyart_onHintClick() {
                if (this.state !== 'playing') return;
                if (this.hintsRemaining <= 0) {
                    console.log('No hints remaining');
                    return;
                }
                
                console.log('Using hint');
                
                // Play hint sound
                if (this.audioManager) {
                    this.audioManager.codebyart_playHintSound();
                }
                
                // Use a hint
                this.codebyart_useHint();
            }
            
            /**
             * Handle mute button click
             * Toggles audio on/off
             */
            codebyart_onMuteClick() {
                console.log('Toggling mute');
                
                if (this.audioManager) {
                    const isMuted = this.audioManager.codebyart_toggleMute();
                    console.log(`Audio ${isMuted ? 'muted' : 'unmuted'}`);
                }
            }
            
            /**
             * Handle pause button click
             * Pauses/resumes the game
             */
            codebyart_onPauseClick() {
                if (this.state !== 'playing') return;
                
                console.log('Toggling pause');
                
                // Play sound
                if (this.audioManager) {
                    this.audioManager.codebyart_playStarSelect();
                }
                
                // Toggle pause state
                this.codebyart_togglePause();
            }
            
            /**
             * Handle menu button click
             * Returns to main menu
             */
            codebyart_onMenuClick() {
                if (this.state !== 'playing') return;
                
                console.log('Returning to menu');
                
                // Play sound
                if (this.audioManager) {
                    this.audioManager.codebyart_playStarSelect();
                }
                
                // Return to menu
                this.codebyart_returnToMenu();
            }
            
            /**
             * Toggle pause state
             */
            codebyart_togglePause() {
                this.isPaused = !this.isPaused;
                
                if (this.isPaused) {
                    console.log('Game paused');
                } else {
                    console.log('Game resumed');
                    // Reset frame time to prevent time jump
                    this.lastFrameTime = performance.now();
                }
            }
            
            /**
             * Use a hint to reveal next correct connection
             */
            codebyart_useHint() {
                if (this.hintsRemaining <= 0) return;
                
                // Get target sequence
                const targetSequence = this.levelManager.codebyart_getTargetSequence();
                if (!targetSequence || targetSequence.length === 0) return;
                
                // Get current connections
                const currentConnections = this.connectionManager.codebyart_getConnections();
                
                // Find the next connection that hasn't been made yet
                let nextConnection = null;
                for (let target of targetSequence) {
                    const alreadyMade = currentConnections.some(conn => 
                        conn.from === target.from && conn.to === target.to
                    );
                    
                    if (!alreadyMade) {
                        nextConnection = target;
                        break;
                    }
                }
                
                if (!nextConnection) {
                    console.log('All connections already made');
                    return;
                }
                
                // Highlight the next star to connect
                const nextStarId = currentConnections.length === 0 ? nextConnection.from : nextConnection.to;
                const nextStar = this.stars.find(star => star.codebyart_getId() === nextStarId);
                
                if (nextStar) {
                    // Show hint animation on the star
                    nextStar.codebyart_setHint(true);
                    
                    // Clear hint after 2 seconds
                    setTimeout(() => {
                        if (nextStar) {
                            nextStar.codebyart_setHint(false);
                        }
                    }, 2000);
                }
                
                // Decrement hints remaining
                this.hintsRemaining--;
                console.log(`Hints remaining: ${this.hintsRemaining}`);
            }
            
            /**
             * Setup canvas click handler for state transitions
             */
            codebyart_setupCanvasClickHandler() {
                this.canvas.addEventListener('click', (e) => {
                    this.codebyart_handleCanvasClick(e);
                });
            }
            
            /**
             * Setup canvas context loss and recovery handlers
             * Handles WebGL context loss gracefully
             */
            codebyart_setupContextLossHandlers() {
                if (!this.canvas) {
                    console.warn('Cannot setup context loss handlers: Canvas not available');
                    return;
                }
                
                // Handle context loss
                this.canvas.addEventListener('webglcontextlost', (e) => {
                    console.error('Canvas context lost');
                    e.preventDefault(); // Prevent default behavior
                    
                    // Pause game if playing
                    if (this.state === 'playing') {
                        this.isPaused = true;
                    }
                    
                    // Stop game loop
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                        this.animationFrameId = null;
                    }
                    
                    // Show error message to user
                    this.codebyart_showContextLostMessage();
                }, false);
                
                // Handle context restoration
                this.canvas.addEventListener('webglcontextrestored', () => {
                    console.log('Canvas context restored');
                    
                    try {
                        // Reinitialize context
                        this.ctx = this.canvas.getContext('2d');
                        
                        if (!this.ctx) {
                            console.error('Failed to restore canvas context');
                            alert('Failed to restore game graphics. Please refresh the page.');
                            return;
                        }
                        
                        // Reinitialize renderer with new context
                        if (this.renderer) {
                            this.renderer.ctx = this.ctx;
                            this.renderer.codebyart_initializeStarfield();
                        }
                        
                        // Resume game loop
                        this.codebyart_startGameLoop();
                        
                        // Resume game if it was playing
                        if (this.state === 'playing') {
                            this.isPaused = false;
                        }
                        
                        console.log('Game graphics restored successfully');
                    } catch (e) {
                        console.error('Error restoring canvas context:', e);
                        alert('Error restoring game graphics. Please refresh the page.');
                    }
                }, false);
                
                console.log('Context loss handlers setup complete');
            }
            
            /**
             * Show context lost error message
             * Displays a message to the user when canvas context is lost
             */
            codebyart_showContextLostMessage() {
                // This could be enhanced with a custom UI overlay
                // For now, we'll just log and the game will attempt to recover
                console.warn('Graphics context lost. Attempting to recover...');
            }
            
            /**
             * Handle canvas clicks for state transitions and menu interactions
             * @param {MouseEvent} e - Mouse event
             */
            codebyart_handleCanvasClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Handle clicks based on current state
                switch (this.state) {
                    case 'tutorial':
                        // Any click dismisses tutorial
                        this.codebyart_dismissTutorial();
                        break;
                        
                    case 'menu':
                        // Check if clicking on a level button
                        this.codebyart_handleMenuClick(x, y);
                        break;
                        
                    case 'levelComplete':
                        // Any click advances to next level or menu
                        this.codebyart_advanceFromLevelComplete();
                        break;
                        
                    case 'gameComplete':
                        // Any click returns to menu
                        this.codebyart_returnToMenu();
                        break;
                        
                    case 'playing':
                        // Handle star clicks (already handled by InputHandler)
                        break;
                }
            }
            
            /**
             * Dismiss tutorial and go to menu
             */
            codebyart_dismissTutorial() {
                console.log('Tutorial dismissed');
                
                // Mark tutorial as shown
                this.storageManager.codebyart_saveSetting('tutorialShown', true);
                this.settings.tutorialShown = true;
                
                // Transition to menu
                this.codebyart_changeState('menu');
            }
            
            /**
             * Handle menu click to select level
             * @param {number} x - Click X coordinate
             * @param {number} y - Click Y coordinate
             */
            codebyart_handleMenuClick(x, y) {
                // Check if clicking on Clear Progress button
                if (this.renderer && this.renderer.clearProgressButton) {
                    const btn = this.renderer.clearProgressButton;
                    if (x >= btn.x && x <= btn.x + btn.width &&
                        y >= btn.y && y <= btn.y + btn.height) {
                        console.log('Clear Progress button clicked');
                        this.codebyart_clearAllProgress();
                        return;
                    }
                }
                
                // Calculate level grid positions (same as in renderMenu)
                const cols = 3;
                // Ensure minimum 44px touch target for accessibility
                const buttonSize = Math.max(44, Math.min(80, (this.canvas.width - 100) / cols));
                const buttonGap = Math.max(8, 15); // Minimum 8px spacing
                const gridWidth = (buttonSize * cols) + (buttonGap * (cols - 1));
                const startX = (this.canvas.width - gridWidth) / 2;
                const startY = 120;
                
                // Check each level button
                for (let i = 0; i < 15; i++) {
                    const levelNum = i + 1;
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const buttonX = startX + (col * (buttonSize + buttonGap));
                    const buttonY = startY + (row * (buttonSize + buttonGap));
                    
                    // Check if click is within button bounds
                    if (x >= buttonX && x <= buttonX + buttonSize &&
                        y >= buttonY && y <= buttonY + buttonSize) {
                        
                        // Check if level is unlocked
                        const isUnlocked = levelNum === 1 || 
                                          (this.progress.completedLevels && 
                                           this.progress.completedLevels.includes(levelNum - 1));
                        
                        if (isUnlocked) {
                            console.log(`Level ${levelNum} selected from menu`);
                            this.codebyart_startLevel(levelNum);
                            return;
                        } else {
                            console.log(`Level ${levelNum} is locked`);
                        }
                    }
                }
            }
            
            /**
             * Advance from level complete screen
             */
            codebyart_advanceFromLevelComplete() {
                console.log('Advancing from level complete screen');
                
                // Check if there are more levels
                if (this.currentLevel < codebyart_CONSTELLATION_DATA.length) {
                    // Start next level
                    this.codebyart_startLevel(this.currentLevel + 1);
                } else {
                    // All levels complete, return to menu
                    this.codebyart_returnToMenu();
                }
            }
            
            /**
             * Generate background starfield
             */
            codebyart_generateBackgroundStars() {
                this.backgroundStars = [];
                const starCount = 100;
                
                for (let i = 0; i < starCount; i++) {
                    this.backgroundStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 0.5,
                        brightness: Math.random(),
                        twinkleSpeed: Math.random() * 0.002 + 0.001,
                        twinklePhase: Math.random() * Math.PI * 2
                    });
                }
            }
            
            /**
             * Start the game loop with requestAnimationFrame
             */
            codebyart_startGameLoop() {
                this.lastFrameTime = performance.now();
                
                // Initialize FPS tracking
                this.fpsFrames = 0;
                this.fpsLastTime = performance.now();
                this.currentFPS = 60;
                this.fpsUpdateInterval = 1000; // Update FPS display every second
                
                // Initialize performance tracking
                this.performanceStats = {
                    updateTime: 0,
                    renderTime: 0,
                    totalTime: 0
                };
                
                this.codebyart_gameLoop(this.lastFrameTime);
            }
            
            /**
             * Main game loop - called every frame via requestAnimationFrame
             * Optimized for 60 FPS target with performance monitoring
             * @param {number} timestamp - Current timestamp from requestAnimationFrame
             */
            codebyart_gameLoop(timestamp) {
                const frameStartTime = performance.now();
                
                // Calculate delta time (capped to prevent spiral of death)
                const deltaTime = Math.min(timestamp - this.lastFrameTime, 100);
                this.lastFrameTime = timestamp;
                
                // Update FPS counter
                this.fpsFrames++;
                if (timestamp - this.fpsLastTime >= this.fpsUpdateInterval) {
                    this.currentFPS = Math.round((this.fpsFrames * 1000) / (timestamp - this.fpsLastTime));
                    this.fpsFrames = 0;
                    this.fpsLastTime = timestamp;
                }
                
                // Update game state
                const updateStartTime = performance.now();
                this.codebyart_update(deltaTime);
                this.performanceStats.updateTime = performance.now() - updateStartTime;
                
                // Render game
                const renderStartTime = performance.now();
                this.codebyart_render();
                this.performanceStats.renderTime = performance.now() - renderStartTime;
                
                // Calculate total frame time
                this.performanceStats.totalTime = performance.now() - frameStartTime;
                
                // Continue loop
                this.animationFrameId = requestAnimationFrame((ts) => this.codebyart_gameLoop(ts));
            }
            
            /**
             * Update all game entities with deltaTime
             * Optimized to minimize memory allocations and improve performance
             * @param {number} deltaTime - Time elapsed since last frame in milliseconds
             */
            codebyart_update(deltaTime) {
                // Store deltaTime for rendering
                this.lastDeltaTime = deltaTime;
                
                // Update fade transitions
                if (this.fadeDirection !== 0) {
                    this.fadeAlpha += this.fadeDirection * this.fadeSpeed;
                    
                    // Clamp alpha
                    if (this.fadeAlpha >= 1) {
                        this.fadeAlpha = 1;
                        this.fadeDirection = 0;
                        if (this.fadeCallback) {
                            this.fadeCallback();
                            this.fadeCallback = null;
                        }
                    } else if (this.fadeAlpha <= 0) {
                        this.fadeAlpha = 0;
                        this.fadeDirection = 0;
                        if (this.fadeCallback) {
                            this.fadeCallback();
                            this.fadeCallback = null;
                        }
                    }
                }
                
                // Update particle system (only if active particles exist)
                if (this.particleSystem && this.particleSystem.codebyart_getActiveCount() > 0) {
                    this.particleSystem.codebyart_update(deltaTime);
                }
                
                // Update screen shake effect (200ms subtle shake for errors)
                if (this.screenShakeActive) {
                    this.screenShakeProgress += deltaTime / this.screenShakeDuration;
                    
                    if (this.screenShakeProgress >= 1) {
                        // End shake
                        this.screenShakeProgress = 0;
                        this.screenShakeActive = false;
                        this.screenShakeOffsetX = 0;
                        this.screenShakeOffsetY = 0;
                    } else {
                        // Calculate shake offset with decay
                        const decay = 1 - this.screenShakeProgress;
                        const angle = Math.random() * Math.PI * 2;
                        this.screenShakeOffsetX = Math.cos(angle) * this.screenShakeIntensity * decay;
                        this.screenShakeOffsetY = Math.sin(angle) * this.screenShakeIntensity * decay;
                    }
                }
                
                // Update score animation (300ms count-up)
                if (this.scoreAnimationActive) {
                    this.scoreAnimationProgress += deltaTime / this.scoreAnimationDuration;
                    
                    if (this.scoreAnimationProgress >= 1) {
                        this.scoreAnimationProgress = 1;
                        this.scoreAnimationActive = false;
                        this.scoreAnimationCurrentValue = this.scoreAnimationTargetValue;
                    } else {
                        // Ease out cubic for smooth count-up
                        const easeProgress = 1 - Math.pow(1 - this.scoreAnimationProgress, 3);
                        this.scoreAnimationCurrentValue = this.scoreAnimationStartValue + 
                            (this.scoreAnimationTargetValue - this.scoreAnimationStartValue) * easeProgress;
                    }
                }
                
                // Update level transition animation (500ms fade)
                if (this.levelTransitionActive) {
                    this.levelTransitionProgress += deltaTime / this.levelTransitionDuration;
                    
                    if (this.levelTransitionProgress >= 1) {
                        this.levelTransitionProgress = 1;
                        this.levelTransitionActive = false;
                        this.levelTransitionAlpha = 0;
                    } else {
                        // Fade in then fade out
                        if (this.levelTransitionProgress < 0.5) {
                            this.levelTransitionAlpha = this.levelTransitionProgress * 2;
                        } else {
                            this.levelTransitionAlpha = 2 - (this.levelTransitionProgress * 2);
                        }
                    }
                }
                
                // Update hint icon animation (200ms scale pulse)
                if (this.hintIconAnimationActive) {
                    this.hintIconAnimationProgress += deltaTime / this.hintIconAnimationDuration;
                    
                    if (this.hintIconAnimationProgress >= 1) {
                        this.hintIconAnimationProgress = 0;
                        this.hintIconAnimationActive = false;
                        this.hintIconScale = 1;
                    } else {
                        // Scale up then down
                        if (this.hintIconAnimationProgress < 0.5) {
                            this.hintIconScale = 1 + (this.hintIconAnimationProgress * 2) * 0.3;
                        } else {
                            this.hintIconScale = 1.3 - ((this.hintIconAnimationProgress - 0.5) * 2) * 0.3;
                        }
                    }
                }
                
                // Update based on game state
                switch (this.state) {
                    case 'playing':
                        if (!this.isPaused) {
                            // Update level timer
                            this.levelElapsedTime += deltaTime;
                            
                            // Update background stars (use for loop for better performance)
                            for (let i = 0; i < this.backgroundStars.length; i++) {
                                this.backgroundStars[i].twinklePhase += this.backgroundStars[i].twinkleSpeed * deltaTime;
                            }
                            
                            // Update star nodes (use for loop for better performance)
                            for (let i = 0; i < this.stars.length; i++) {
                                this.stars[i].codebyart_update(deltaTime);
                            }
                            
                            // Update connection animations
                            if (this.connectionManager) {
                                this.connectionManager.codebyart_updateAnimations(deltaTime);
                            }
                        }
                        break;
                        
                    case 'menu':
                    case 'tutorial':
                    case 'levelComplete':
                    case 'gameComplete':
                        // Update background stars even in menu (use for loop for better performance)
                        for (let i = 0; i < this.backgroundStars.length; i++) {
                            this.backgroundStars[i].twinklePhase += this.backgroundStars[i].twinkleSpeed * deltaTime;
                        }
                        break;
                }
            }
            
            /**
             * Coordinate all rendering
             */
            codebyart_render() {
                if (!this.renderer) return;
                
                // Calculate deltaTime for animations (use last frame's deltaTime)
                const deltaTime = this.lastDeltaTime || 16; // Default to ~60fps if not set
                
                // Apply screen shake transform if active
                if (this.screenShakeActive) {
                    this.ctx.save();
                    this.ctx.translate(this.screenShakeOffsetX, this.screenShakeOffsetY);
                }
                
                // Render based on game state
                switch (this.state) {
                    case 'menu':
                        this.renderer.codebyart_renderBackground();
                        this.renderer.codebyart_renderNebulaEffects(deltaTime);
                        this.renderer.codebyart_renderStarfield(deltaTime);
                        this.renderer.codebyart_renderCosmicDust(deltaTime);
                        this.renderer.codebyart_renderMenu(this.progress);
                        break;
                        
                    case 'tutorial':
                        this.renderer.codebyart_renderBackground();
                        this.renderer.codebyart_renderNebulaEffects(deltaTime);
                        this.renderer.codebyart_renderStarfield(deltaTime);
                        this.renderer.codebyart_renderCosmicDust(deltaTime);
                        this.renderer.codebyart_renderTutorial();
                        break;
                        
                    case 'playing':
                        this.renderer.codebyart_renderBackground();
                        this.renderer.codebyart_renderNebulaEffects(deltaTime);
                        this.renderer.codebyart_renderStarfield(deltaTime);
                        this.renderer.codebyart_renderCosmicDust(deltaTime);
                        
                        // Render connections (behind stars)
                        if (this.connectionManager) {
                            this.connectionManager.codebyart_renderConnections(this.ctx, this.stars);
                        }
                        
                        // Render stars
                        this.renderer.codebyart_renderStars(this.stars);
                        
                        // Render particles (on top of stars)
                        if (this.particleSystem) {
                            this.particleSystem.codebyart_render(this.ctx);
                        }
                        
                        // Render ghost pattern if Hint Level 3 is active
                        if (this.showingCompletePattern) {
                            this.codebyart_renderGhostPattern();
                        }
                        
                        // Render UI
                        const levelData = this.levelManager ? this.levelManager.codebyart_getCurrentLevel() : null;
                        this.renderer.codebyart_renderUI({
                            level: this.currentLevel,
                            levelName: levelData ? levelData.name : '',
                            difficulty: levelData ? levelData.difficulty : '',
                            hintsRemaining: this.hintsRemaining,
                            hintLevel: this.hintLevel,
                            undoRemaining: this.undoLimit - this.undoCount,
                            undoLimit: this.undoLimit,
                            time: this.levelElapsedTime / 1000,
                            isMuted: this.audioManager ? this.audioManager.codebyart_isMuted() : false,
                            isPaused: this.isPaused,
                            bestTime: this.currentLevelBestTime,
                            bestStars: this.currentLevelBestStars,
                            hoveredButton: this.hoveredButton,
                            fps: this.currentFPS,
                            isMobile: this.codebyart_isMobile(),
                            // Animation states (Requirement 7.3)
                            levelTransitionAlpha: this.levelTransitionAlpha,
                            hintIconScale: this.hintIconScale
                        });
                        
                        // Register UI buttons for interaction after rendering
                        this.codebyart_registerUIButtons();
                        
                        // Render pause overlay if paused
                        if (this.isPaused) {
                            this.renderer.codebyart_renderPauseOverlay();
                        }
                        break;
                        
                    case 'levelComplete':
                        this.renderer.codebyart_renderBackground();
                        this.renderer.codebyart_renderNebulaEffects(deltaTime);
                        this.renderer.codebyart_renderStarfield(deltaTime);
                        this.renderer.codebyart_renderCosmicDust(deltaTime);
                        
                        // Render the completed constellation
                        if (this.connectionManager) {
                            this.connectionManager.codebyart_renderConnections(this.ctx, this.stars);
                        }
                        this.renderer.codebyart_renderStars(this.stars);
                        
                        // Render celebration particles
                        if (this.particleSystem) {
                            this.particleSystem.codebyart_render(this.ctx);
                        }
                        
                        // Render completion overlay
                        const completionData = {
                            levelNumber: this.currentLevel,
                            levelName: this.levelManager ? this.levelManager.codebyart_getCurrentLevel().name : '',
                            stars: this.lastLevelStars || 3,
                            time: this.levelElapsedTime / 1000,
                            hintsUsed: 3 - this.hintsRemaining,
                            description: this.levelManager ? this.levelManager.codebyart_getCurrentLevel().description : '',
                            isNewBest: this.isNewBestTime || false
                        };
                        this.renderer.codebyart_renderLevelComplete(completionData);
                        break;
                        
                    case 'gameComplete':
                        this.renderer.codebyart_renderBackground();
                        this.renderer.codebyart_renderNebulaEffects(deltaTime);
                        this.renderer.codebyart_renderStarfield(deltaTime);
                        this.renderer.codebyart_renderCosmicDust(deltaTime);
                        
                        // Render celebration particles
                        if (this.particleSystem) {
                            this.particleSystem.codebyart_render(this.ctx);
                        }
                        
                        this.renderer.codebyart_renderGameComplete(this.progress, this.sessionStats);
                        break;
                }
                
                // Restore context if screen shake was applied
                if (this.screenShakeActive) {
                    this.ctx.restore();
                }
                
                // Render level transition overlay (500ms fade for level changes)
                if (this.levelTransitionActive && this.levelTransitionAlpha > 0) {
                    this.ctx.save();
                    this.ctx.fillStyle = `rgba(10, 14, 39, ${this.levelTransitionAlpha * 0.8})`;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Show level number during transition
                    if (this.levelTransitionAlpha > 0.3) {
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${this.levelTransitionAlpha})`;
                        this.ctx.font = `bold ${48}px 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        this.ctx.shadowBlur = 10;
                        this.ctx.fillText(`Level ${this.currentLevel}`, this.canvas.width / 2, this.canvas.height / 2);
                    }
                    
                    this.ctx.restore();
                }
                
                // Render fade overlay (always on top)
                if (this.fadeAlpha > 0) {
                    this.ctx.save();
                    this.ctx.fillStyle = `rgba(0, 0, 0, ${this.fadeAlpha})`;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.restore();
                }
            }
            
            /**
             * Start a specific level
             * @param {number} levelNumber - Level number to start (1-15)
             */
            codebyart_startLevel(levelNumber) {
                console.log(`Starting level ${levelNumber}`);
                
                // Validate level number
                if (levelNumber < 1 || levelNumber > codebyart_CONSTELLATION_DATA.length) {
                    console.error(`Invalid level number: ${levelNumber}`);
                    return;
                }
                
                // Load level data
                const loaded = this.levelManager.codebyart_loadLevel(levelNumber);
                if (!loaded) {
                    console.error(`Failed to load level ${levelNumber}`);
                    return;
                }
                
                // Set current level
                this.currentLevel = levelNumber;
                
                // Trigger level transition animation (500ms fade)
                this.codebyart_triggerLevelTransition();
                
                // Load and display previous best scores (Requirement 6.3)
                this.currentLevelBestTime = null;
                this.currentLevelBestStars = null;
                
                if (this.progress && this.progress.levelData && this.progress.levelData[levelNumber]) {
                    const levelData = this.progress.levelData[levelNumber];
                    this.currentLevelBestTime = levelData.bestTime;
                    this.currentLevelBestStars = levelData.stars;
                    console.log(`Previous best for level ${levelNumber}: ${this.currentLevelBestStars} stars, ${this.currentLevelBestTime.toFixed(1)}s`);
                } else {
                    console.log(`No previous record for level ${levelNumber}`);
                }
                
                // Reset level state
                this.selectedStars = [];
                
                // Reset hints to 3 for new level (Requirement 10.5)
                this.hintsRemaining = 3;
                this.hintLevel = 0;
                this.hintUsedLevel3 = false;
                
                // Set undo limit based on difficulty
                if (levelNumber <= 5) {
                    this.undoLimit = 3; // Easy levels
                } else if (levelNumber <= 10) {
                    this.undoLimit = 5; // Medium levels
                } else {
                    this.undoLimit = 7; // Hard levels
                }
                this.undoCount = 0;
                this.connectionHistory = [];
                
                this.levelStartTime = performance.now();
                this.levelElapsedTime = 0;
                this.isPaused = false;
                
                // Clear connections
                if (this.connectionManager) {
                    this.connectionManager.codebyart_clearConnections();
                }
                
                // Create star nodes from level data
                const starPositions = this.levelManager.codebyart_getStarPositions();
                this.stars = starPositions.map(pos => 
                    new codebyart_StarNode(pos.x, pos.y, pos.id, pos.size)
                );
                
                // Change state to playing
                this.codebyart_changeState('playing');
                
                console.log(`Level ${levelNumber} started with ${this.stars.length} stars and ${this.hintsRemaining} hints`);
            }
            
            /**
             * Handle level completion and progression
             */
            codebyart_completeLevel() {
                console.log(`Level ${this.currentLevel} completed!`);
                
                // Calculate hints used (needed for progress saving)
                const hintsUsed = 3 - this.hintsRemaining;
                
                // Check if hint level 3 was used (forfeits score)
                let stars = 0;
                if (this.hintUsedLevel3) {
                    stars = 0;
                    console.log('Hint Level 3 was used - No stars awarded');
                } else {
                    // Calculate star rating based on accuracy and hints used (Requirement 10.4)
                    const accuracy = 100; // Perfect accuracy since they completed it correctly
                    stars = this.levelManager.codebyart_calculateStarRating(accuracy, hintsUsed);
                    console.log(`Star rating: ${stars}/3 (hints used: ${hintsUsed})`);
                }
                
                this.lastLevelStars = stars;
                
                // Trigger score animation (300ms count-up)
                this.codebyart_triggerScoreAnimation(stars);
                
                // Check if this is a new best time (Requirement 6.3)
                const timeInSeconds = this.levelElapsedTime / 1000;
                this.isNewBestTime = false;
                
                if (this.currentLevelBestTime === null || timeInSeconds < this.currentLevelBestTime) {
                    this.isNewBestTime = true;
                    console.log(`New best time for level ${this.currentLevel}! ${timeInSeconds.toFixed(1)}s (previous: ${this.currentLevelBestTime ? this.currentLevelBestTime.toFixed(1) + 's' : 'none'})`);
                }
                
                // Save progress (Requirement 6.4)
                this.storageManager.codebyart_saveProgress(
                    this.currentLevel,
                    stars,
                    timeInSeconds,
                    hintsUsed
                );
                
                // Reload progress
                this.progress = this.storageManager.codebyart_loadProgress();
                
                // Track session statistics (Requirement 6.1)
                this.sessionLevelsCompleted++;
                this.sessionStats.levelsCompleted++;
                this.sessionStats.totalStars += stars;
                this.sessionStats.totalTime += timeInSeconds;
                this.sessionStats.hintsUsed += hintsUsed;
                
                console.log(`Session stats: ${this.sessionStats.levelsCompleted} levels, ${this.sessionStats.totalStars} stars, ${this.sessionStats.totalTime.toFixed(1)}s`);
                
                // Play completion sound
                if (this.audioManager) {
                    this.audioManager.codebyart_playLevelComplete();
                }
                
                // Emit celebration particles at center of canvas
                if (this.particleSystem) {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    this.particleSystem.codebyart_emitCelebration(centerX, centerY);
                }
                
                // Check if all levels completed
                if (this.currentLevel >= codebyart_CONSTELLATION_DATA.length) {
                    console.log('All levels completed! Game complete!');
                    this.codebyart_changeState('gameComplete');
                    
                    // Emit extra celebration for game completion
                    if (this.particleSystem) {
                        setTimeout(() => {
                            const centerX = this.canvas.width / 2;
                            const centerY = this.canvas.height / 2;
                            this.particleSystem.codebyart_emitCelebration(centerX, centerY);
                        }, 500);
                    }
                } else {
                    // Show level complete screen
                    this.codebyart_changeState('levelComplete');
                }
            }
            
            /**
             * Reset current level
             */
            codebyart_resetLevel() {
                console.log(`Resetting level ${this.currentLevel}`);
                
                // Clear selections
                this.selectedStars = [];
                
                // Clear connections
                if (this.connectionManager) {
                    this.connectionManager.codebyart_clearConnections();
                }
                
                // Reset all stars to default state
                this.stars.forEach(star => {
                    star.codebyart_deselect();
                    star.isConnected = false;
                    star.isHinted = false;
                });
                
                // Reset hints
                this.hintsRemaining = 3;
                
                // Reset timer
                this.levelStartTime = performance.now();
                this.levelElapsedTime = 0;
                
                // Unpause if paused
                this.isPaused = false;
                
                console.log('Level reset complete');
            }
            
            /**
             * Use a hint to reveal next correct connection
             * Shows the next star to connect with a golden glow animation
             */
            codebyart_useHint() {
                // Check if hints are available
                if (this.hintsRemaining <= 0) {
                    console.log('No hints remaining');
                    if (this.audioManager) {
                        this.audioManager.codebyart_playConnectionError();
                    }
                    return;
                }
                
                // Check if in playing state and not paused
                if (this.state !== 'playing' || this.isPaused) {
                    console.log('Cannot use hint in current state');
                    return;
                }
                
                // Get target sequence and current connections
                const targetSequence = this.levelManager.codebyart_getTargetSequence();
                const currentConnections = this.connectionManager.codebyart_getConnections();
                
                // Check if level is already complete
                if (currentConnections.length >= targetSequence.length) {
                    console.log('Level already complete, no hint needed');
                    return;
                }
                
                // Increment hint level
                this.hintLevel++;
                
                if (this.hintLevel === 1) {
                    // HINT LEVEL 1: Show next star with golden glow
                    this.codebyart_showHintLevel1(targetSequence, currentConnections);
                } else if (this.hintLevel === 2) {
                    // HINT LEVEL 2: Show next star with stronger glow
                    this.codebyart_showHintLevel2(targetSequence, currentConnections);
                } else if (this.hintLevel >= 3) {
                    // HINT LEVEL 3: Show complete pattern (with confirmation)
                    this.codebyart_showHintLevel3Confirmation();
                    return; // Don't decrement hints yet, wait for confirmation
                }
                
                // Decrement hints remaining
                this.hintsRemaining--;
                console.log(`Hint Level ${this.hintLevel} used. ${this.hintsRemaining} hints remaining`);
                
                // Trigger hint icon animation (200ms scale pulse)
                this.codebyart_triggerHintIconAnimation();
                
                // Play hint sound
                if (this.audioManager) {
                    this.audioManager.codebyart_playHintSound();
                }
            }
            
            /**
             * Hint Level 1: Show next star with golden glow
             */
            codebyart_showHintLevel1(targetSequence, currentConnections) {
                console.log('Hint Level 1: Showing next star');
                const nextConnection = targetSequence[currentConnections.length];
                console.log('Next connection:', nextConnection);
                let starToHighlight = null;
                
                if (this.selectedStars.length === 0) {
                    starToHighlight = this.stars.find(s => s.id === nextConnection.from);
                    console.log(`No stars selected. Highlighting start star: ${nextConnection.from}`);
                } else if (this.selectedStars.length === 1) {
                    const selectedStarId = this.selectedStars[0];
                    if (selectedStarId === nextConnection.from) {
                        starToHighlight = this.stars.find(s => s.id === nextConnection.to);
                        console.log(`Correct star selected. Highlighting target star: ${nextConnection.to}`);
                    } else {
                        starToHighlight = this.stars.find(s => s.id === nextConnection.from);
                        console.log(`Wrong star selected. Highlighting correct start star: ${nextConnection.from}`);
                    }
                }
                
                if (starToHighlight) {
                    console.log(`Highlighting star at position (${starToHighlight.x}, ${starToHighlight.y})`);
                    this.stars.forEach(star => star.codebyart_setHint(false));
                    starToHighlight.codebyart_setHint(true);
                    
                    // Hint pulsing glow duration: 1000ms (Requirement 7.2)
                    setTimeout(() => {
                        if (starToHighlight) {
                            starToHighlight.codebyart_setHint(false);
                            console.log('Hint Level 1 glow removed');
                        }
                    }, 1000);
                } else {
                    console.error('Could not find star to highlight!');
                }
            }
            
            /**
             * Hint Level 2: Show next star with stronger glow (same as level 1 but longer duration)
             */
            codebyart_showHintLevel2(targetSequence, currentConnections) {
                const nextConnection = targetSequence[currentConnections.length];
                let starToHighlight = null;
                
                if (this.selectedStars.length === 0) {
                    starToHighlight = this.stars.find(s => s.id === nextConnection.from);
                } else if (this.selectedStars.length === 1) {
                    const selectedStarId = this.selectedStars[0];
                    if (selectedStarId === nextConnection.from) {
                        starToHighlight = this.stars.find(s => s.id === nextConnection.to);
                    } else {
                        starToHighlight = this.stars.find(s => s.id === nextConnection.from);
                    }
                }
                
                if (starToHighlight) {
                    this.stars.forEach(star => star.codebyart_setHint(false));
                    starToHighlight.codebyart_setHint(true);
                    
                    // Hint pulsing glow duration: 1000ms (Requirement 7.2)
                    setTimeout(() => {
                        if (starToHighlight) starToHighlight.codebyart_setHint(false);
                    }, 1000);
                }
            }
            
            /**
             * Hint Level 3: Show confirmation before revealing complete pattern
             */
            codebyart_showHintLevel3Confirmation() {
                const confirmed = confirm(
                    ' WARNING: Using this hint will show the complete constellation pattern, but you will forfeit your score for this level.\n\n' +
                    'You will receive 0 stars even if you complete the level.\n\n' +
                    'Do you want to continue?'
                );
                
                if (confirmed) {
                    this.hintUsedLevel3 = true;
                    this.hintsRemaining--;
                    this.codebyart_showCompletePattern();
                    console.log('Hint Level 3 used - Score forfeited');
                } else {
                    this.hintLevel--; // Revert hint level if cancelled
                    console.log('Hint Level 3 cancelled');
                }
            }
            
            /**
             * Show complete constellation pattern as ghost overlay
             */
            codebyart_showCompletePattern() {
                // This will be rendered by the renderer as a ghost overlay
                this.showingCompletePattern = true;
                
                if (this.audioManager) {
                    this.audioManager.codebyart_playHintSound();
                }
            }
            
            /**
             * Render ghost pattern overlay showing complete constellation
             */
            codebyart_renderGhostPattern() {
                const ctx = this.ctx;
                const targetSequence = this.levelManager.codebyart_getTargetSequence();
                
                ctx.save();
                
                // Draw all target connections as ghost lines
                targetSequence.forEach(conn => {
                    const fromStar = this.stars.find(s => s.id === conn.from);
                    const toStar = this.stars.find(s => s.id === conn.to);
                    
                    if (fromStar && toStar) {
                        const fromPos = fromStar.codebyart_getPosition();
                        const toPos = toStar.codebyart_getPosition();
                        
                        // Draw ghost line (semi-transparent white)
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]); // Dashed line
                        ctx.lineCap = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(fromPos.x, fromPos.y);
                        ctx.lineTo(toPos.x, toPos.y);
                        ctx.stroke();
                    }
                });
                
                ctx.setLineDash([]); // Reset line dash
                ctx.restore();
            }
            
            /**
             * Undo the last connection
             */
            codebyart_undoLastConnection() {
                // Check if undo limit reached
                if (this.undoCount >= this.undoLimit) {
                    console.log(`No undos remaining (${this.undoCount}/${this.undoLimit} used)`);
                    if (this.audioManager) {
                        this.audioManager.codebyart_playConnectionError();
                    }
                    return;
                }
                
                // Check if there are connections to undo
                if (this.connectionHistory.length === 0) {
                    console.log('Nothing to undo');
                    if (this.audioManager) {
                        this.audioManager.codebyart_playConnectionError();
                    }
                    return;
                }
                
                // Check if in playing state
                if (this.state !== 'playing' || this.isPaused) {
                    console.log('Cannot undo in current state');
                    return;
                }
                
                // Remove last connection from history
                const lastConnection = this.connectionHistory.pop();
                
                // Remove from connection manager
                this.connectionManager.codebyart_removeLastConnection();
                
                // Update star states
                const fromStar = this.stars.find(s => s.id === lastConnection.from);
                const toStar = this.stars.find(s => s.id === lastConnection.to);
                
                // Check if these stars are still connected in other connections
                const remainingConnections = this.connectionManager.codebyart_getConnections();
                const fromStillConnected = remainingConnections.some(c => c.from === lastConnection.from || c.to === lastConnection.from);
                const toStillConnected = remainingConnections.some(c => c.from === lastConnection.to || c.to === lastConnection.to);
                
                if (fromStar && !fromStillConnected) {
                    fromStar.isConnected = false;
                }
                if (toStar && !toStillConnected) {
                    toStar.isConnected = false;
                }
                
                // Clear selection
                this.selectedStars = [];
                this.stars.forEach(star => star.codebyart_deselect());
                
                // Increment undo count
                this.undoCount++;
                
                // Play sound (reuse connection error sound for undo)
                if (this.audioManager) {
                    this.audioManager.codebyart_playConnectionError();
                }
                
                console.log(`Undo successful. ${this.undoLimit - this.undoCount} undos remaining`);
            }
            
            /**
             * Toggle pause state
             */
            codebyart_togglePause() {
                if (this.state !== 'playing') return;
                
                this.isPaused = !this.isPaused;
                console.log(`Game ${this.isPaused ? 'paused' : 'resumed'}`);
            }
            
            /**
             * Change game state with proper cleanup
             * Optimized to clear unused resources and event listeners
             * @param {string} newState - The new state to transition to
             */
            codebyart_changeState(newState) {
                const oldState = this.state;
                
                // Cleanup based on old state
                if (oldState === 'playing') {
                    // Clear any playing-specific resources
                    if (this.particleSystem) {
                        // Don't clear particles, just let them fade naturally
                    }
                }
                
                // Set new state
                this.state = newState;
                
                // Log state change
                console.log(`State changed: ${oldState} -> ${newState}`);
            }
            
            /**
             * Return to main menu
             */
            codebyart_returnToMenu() {
                console.log('Returning to menu');
                this.codebyart_changeState('menu');
                this.currentLevel = 1;
                this.isPaused = false;
            }
            
            /**
             * Handle input down event (mouse/touch)
             * @param {number} x - Canvas X coordinate
             * @param {number} y - Canvas Y coordinate
             * @param {string} inputType - 'mouse' or 'touch'
             */
            codebyart_onInputDown(x, y, inputType) {
                if (this.state !== 'playing' || this.isPaused) return;
                
                // Check for UI button clicks first
                if (this.codebyart_checkUIButtonClick(x, y)) {
                    return; // Button was clicked, don't process star selection
                }
                
                // Check for star clicks
                for (let star of this.stars) {
                    if (star.codebyart_isPointInside(x, y)) {
                        this.codebyart_handleStarClick(star.id);
                        return;
                    }
                }
            }
            
            /**
             * Handle input move event (mouse/touch)
             * @param {number} x - Canvas X coordinate
             * @param {number} y - Canvas Y coordinate
             * @param {boolean} isActive - Whether input is active (mouse down/touch active)
             * @param {string} inputType - 'mouse' or 'touch'
             */
            codebyart_onInputMove(x, y, isActive, inputType) {
                if (this.state !== 'playing' || this.isPaused) return;
                
                // Update hover state for stars (only for mouse, not touch)
                if (inputType === 'mouse') {
                    let hoveredStar = null;
                    
                    for (let star of this.stars) {
                        if (star.codebyart_isPointInside(x, y)) {
                            hoveredStar = star;
                            star.codebyart_setGlow(true);
                        } else {
                            star.codebyart_setGlow(false);
                        }
                    }
                }
            }
            
            /**
             * Handle input up event (mouse/touch)
             * @param {number} x - Canvas X coordinate
             * @param {number} y - Canvas Y coordinate
             * @param {string} inputType - 'mouse' or 'touch'
             */
            codebyart_onInputUp(x, y, inputType) {
                // Currently no special handling needed for input up
            }
            
            /**
             * Handle input leave event (mouse/touch)
             * @param {string} inputType - 'mouse' or 'touch'
             */
            codebyart_onInputLeave(inputType) {
                if (this.state !== 'playing') return;
                
                // Clear all hover states
                this.stars.forEach(star => {
                    star.codebyart_setGlow(false);
                });
            }
            
            /**
             * Check if a UI button was clicked
             * @param {number} x - Canvas X coordinate
             * @param {number} y - Canvas Y coordinate
             * @returns {boolean} True if a button was clicked
             */
            codebyart_checkUIButtonClick(x, y) {
                if (!this.renderer) return false;
                
                // Calculate button positions (same as in renderUIButtons)
                const buttonY = this.canvas.height - this.renderer.buttonSize - this.renderer.uiPadding;
                const totalWidth = (this.renderer.buttonSize * 4) + (this.renderer.buttonGap * 3);
                let buttonX = (this.canvas.width - totalWidth) / 2;
                
                // Button definitions (same order as in renderUIButtons)
                const buttons = [
                    { id: 'restart', callback: () => this.codebyart_resetLevel() },
                    { id: 'hint', callback: () => this.codebyart_useHint() },
                    { id: 'mute', callback: () => this.audioManager && this.audioManager.codebyart_toggleMute() },
                    { id: 'menu', callback: () => this.codebyart_returnToMenu() }
                ];
                
                // Check each button
                for (let button of buttons) {
                    if (x >= buttonX && x <= buttonX + this.renderer.buttonSize &&
                        y >= buttonY && y <= buttonY + this.renderer.buttonSize) {
                        
                        console.log(`UI button clicked: ${button.id}`);
                        button.callback();
                        return true;
                    }
                    
                    buttonX += this.renderer.buttonSize + this.renderer.buttonGap;
                }
                
                return false;
            }
            
            /**
             * Handle star click/touch
             * @param {number} starId - ID of the clicked star
             */
            codebyart_handleStarClick(starId) {
                if (this.state !== 'playing' || this.isPaused) return;
                
                const star = this.stars.find(s => s.id === starId);
                if (!star) return;
                
                // Play selection sound
                if (this.audioManager) {
                    this.audioManager.codebyart_playStarSelect();
                }
                
                // If no star selected, select this one
                if (this.selectedStars.length === 0) {
                    star.codebyart_select();
                    this.selectedStars.push(starId);
                    console.log(`Star ${starId} selected`);
                }
                // If one star selected, try to make connection
                else if (this.selectedStars.length === 1) {
                    const fromStarId = this.selectedStars[0];
                    const toStarId = starId;
                    
                    // Prevent self-connection
                    if (fromStarId === toStarId) {
                        console.log('Cannot connect star to itself');
                        return;
                    }
                    
                    // Add connection
                    const added = this.connectionManager.codebyart_addConnection(fromStarId, toStarId);
                    
                    if (added) {
                        // Track connection in history for undo
                        this.connectionHistory.push({ from: fromStarId, to: toStarId });
                        // Mark stars as connected
                        const fromStar = this.stars.find(s => s.id === fromStarId);
                        const toStar = this.stars.find(s => s.id === toStarId);
                        
                        if (fromStar) {
                            fromStar.codebyart_deselect();
                            fromStar.isConnected = true;
                        }
                        if (toStar) {
                            toStar.isConnected = true;
                            
                            // Emit particle effect at the connection point
                            if (this.particleSystem) {
                                const toPos = toStar.codebyart_getPosition();
                                this.particleSystem.codebyart_emitConnection(toPos.x, toPos.y);
                            }
                        }
                        
                        // Check if this connection is correct
                        const targetSequence = this.levelManager.codebyart_getTargetSequence();
                        const isCorrectConnection = targetSequence.some(conn => 
                            conn.from === fromStarId && conn.to === toStarId
                        );
                        
                        if (isCorrectConnection) {
                            // Play success sound for correct connection
                            if (this.audioManager) {
                                this.audioManager.codebyart_playConnectionMade();
                            }
                        } else {
                            // Play error sound for incorrect connection
                            if (this.audioManager) {
                                this.audioManager.codebyart_playConnectionError();
                            }
                            
                            // Visual feedback: trigger error flash on both stars (300ms red flash)
                            if (fromStar) {
                                fromStar.codebyart_triggerErrorFlash();
                            }
                            if (toStar) {
                                toStar.codebyart_triggerErrorFlash();
                            }
                            
                            // Trigger screen shake effect (200ms subtle shake)
                            this.codebyart_triggerScreenShake();
                            
                            console.warn(`Incorrect connection: ${fromStarId} -> ${toStarId}`);
                        }
                        
                        // Check if constellation is complete
                        const validation = this.connectionManager.codebyart_validateSequence(targetSequence);
                        
                        console.log('Validation result:', validation);
                        console.log(`Correct: ${validation.correctCount}/${validation.totalRequired}, Valid: ${validation.isValid}, Complete: ${validation.isComplete}`);
                        
                        // Complete when ALL connections are correct (isValid = true)
                        // This means: correct count equals required AND no incorrect connections
                        if (validation.isValid) {
                            console.log(' Constellation complete! All connections correct!');
                            setTimeout(() => {
                                this.codebyart_completeLevel();
                            }, 500);
                        } else {
                            // Clear selection - user must click to start next connection
                            this.selectedStars = [];
                        }
                        
                        console.log(`Connection made: ${fromStarId} -> ${toStarId} (${isCorrectConnection ? 'correct' : 'incorrect'})`);
                    } else {
                        console.log('Connection already exists or invalid');
                        
                        // Play error sound for failed connection attempt
                        if (this.audioManager) {
                            this.audioManager.codebyart_playConnectionError();
                        }
                    }
                }
            }
            
            /**
             * Fade in from black
             * @param {Function} callback - Optional callback when fade completes
             */
            codebyart_fadeIn(callback = null) {
                this.fadeAlpha = 1;
                this.fadeDirection = -1; // Fade out the black overlay (revealing content)
                this.fadeCallback = callback;
                console.log('Fading in...');
            }
            
            /**
             * Fade out to black
             * @param {Function} callback - Optional callback when fade completes
             */
            codebyart_fadeOut(callback = null) {
                this.fadeAlpha = 0;
                this.fadeDirection = 1; // Fade in the black overlay (hiding content)
                this.fadeCallback = callback;
                console.log('Fading out...');
            }
            
            /**
             * Fade transition between states
             * Fades out, executes callback, then fades in
             * @param {Function} callback - Function to execute during fade
             */
            codebyart_fadeTransition(callback) {
                this.codebyart_fadeOut(() => {
                    if (callback) callback();
                    setTimeout(() => {
                        this.codebyart_fadeIn();
                    }, 100);
                });
            }
            
            /**
             * Trigger screen shake effect (200ms subtle shake for errors)
             * Used when incorrect connections are made
             */
            codebyart_triggerScreenShake() {
                this.screenShakeActive = true;
                this.screenShakeProgress = 0;
            }
            
            /**
             * Trigger score animation (300ms count-up)
             * @param {number} targetValue - Target score value to animate to
             */
            codebyart_triggerScoreAnimation(targetValue) {
                this.scoreAnimationStartValue = this.scoreAnimationCurrentValue || 0;
                this.scoreAnimationTargetValue = targetValue;
                this.scoreAnimationActive = true;
                this.scoreAnimationProgress = 0;
            }
            
            /**
             * Trigger level transition animation (500ms fade)
             */
            codebyart_triggerLevelTransition() {
                this.levelTransitionActive = true;
                this.levelTransitionProgress = 0;
            }
            
            /**
             * Trigger hint icon animation (200ms scale pulse)
             */
            codebyart_triggerHintIconAnimation() {
                this.hintIconAnimationActive = true;
                this.hintIconAnimationProgress = 0;
            }
            
            /**
             * Cleanup and destroy game
             */
            codebyart_destroy() {
                console.log('Destroying game...');
                
                // Cancel animation frame
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                
                // Cleanup audio
                if (this.audioManager) {
                    this.audioManager.codebyart_destroy();
                }
                
                // Remove event listeners
                window.removeEventListener('resize', this.codebyart_handleResize);
                window.removeEventListener('orientationchange', this.codebyart_handleResize);
                
                console.log('Game destroyed');
            }
        }
        
        // ===== END CONSTELLATION GAME MAIN CONTROLLER =====
        
        // ===== GAME INITIALIZATION =====
        
        console.log('Constellation Connect - Game structure loaded');
        console.log(`Loaded ${codebyart_CONSTELLATION_DATA.length} constellations`);
        
        // Initialize the game when DOM is ready
        let game = null;
        
        // Wait for DOM to be fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initGame);
        } else {
            // DOM is already loaded
            initGame();
        }
        
        /**
         * Initialize the game
         */
        function initGame() {
            console.log('Initializing game...');
            
            try {
                // Create game instance
                game = new codebyart_ConstellationGame('codebyart-game-canvas');
                
                // Expose game to window for debugging
                window.codebyart_game = game;
                
                console.log(' Game initialized successfully!');
            } catch (error) {
                console.error(' FATAL ERROR initializing game:', error);
                console.error('Error details:', error.message);
                console.error('Stack trace:', error.stack);
                
                // Show error to user
                const canvas = document.getElementById('codebyart-game-canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        ctx.fillStyle = '#ff0000';
                        ctx.font = '20px Arial';
                        ctx.fillText('Game Error - Check Console (F12)', 50, canvas.height / 2);
                        ctx.font = '14px Arial';
                        ctx.fillText(error.message, 50, canvas.height / 2 + 30);
                    }
                }
                
                // Re-throw so it appears in console
                throw error;
            }
            
            // Add keyboard shortcuts for testing
            document.addEventListener('keydown', (e) => {
                if (!game) return;
                
                // Press '1' to start level 1
                if (e.key === '1') {
                    console.log('Starting level 1 (keyboard shortcut)');
                    game.codebyart_startLevel(1);
                }
                
                // Press 'R' to reset level
                if (e.key === 'r' || e.key === 'R') {
                    console.log('Resetting level (keyboard shortcut)');
                    game.codebyart_resetLevel();
                }
                
                // Press 'H' to use hint
                if (e.key === 'h' || e.key === 'H') {
                    console.log('Using hint (keyboard shortcut)');
                    game.codebyart_useHint();
                }
                
                // Press 'U' or Ctrl+Z to undo
                if (e.key === 'u' || e.key === 'U' || (e.ctrlKey && e.key === 'z')) {
                    console.log('Undo last connection (keyboard shortcut)');
                    game.codebyart_undoLastConnection();
                }
                
                // Press 'M' to toggle mute
                if (e.key === 'm' || e.key === 'M') {
                    console.log('Toggling mute (keyboard shortcut)');
                    if (game.audioManager) {
                        game.audioManager.codebyart_toggleMute();
                    }
                }
                
                // Press 'P' to toggle pause
                if (e.key === 'p' || e.key === 'P') {
                    console.log('Toggling pause (keyboard shortcut)');
                    game.codebyart_togglePause();
                }
                
                // Press 'ESC' to return to menu
                if (e.key === 'Escape') {
                    console.log('Returning to menu (keyboard shortcut)');
                    game.codebyart_returnToMenu();
                }
                
                // Press 'Delete' or 'Ctrl+Shift+R' to clear all progress
                if (e.key === 'Delete' || (e.ctrlKey && e.shiftKey && e.key === 'R')) {
                    console.log('Clear all progress (keyboard shortcut)');
                    game.codebyart_clearAllProgress();
                }
            });
            
            console.log('Game initialized! Use keyboard shortcuts:');
            console.log('  1 - Start level 1');
            console.log('  R - Reset level');
            console.log('  H - Use hint (3-tier system)');
            console.log('  U or Ctrl+Z - Undo last connection');
            console.log('  Delete or Ctrl+Shift+R - Clear all progress');
            console.log('  M - Toggle mute');
            console.log('  P - Toggle pause');
            console.log('  ESC - Return to menu');
            
            // Setup orientation change handling
            setupOrientationChangeHandler();
        }
        
        /**
         * Setup orientation change handler for mobile devices
         * Handles screen rotation and recalculates layout
         */
        function setupOrientationChangeHandler() {
            // Detect orientation changes
            const handleOrientationChange = () => {
                if (!game) return;
                
                console.log('Orientation changed, recalculating layout...');
                
                // Small delay to ensure viewport has updated
                setTimeout(() => {
                    // Recalculate canvas dimensions
                    if (game.canvas) {
                        const canvas = game.canvas;
                        const container = canvas.parentElement;
                        
                        if (container) {
                            // Update canvas size to match container
                            const rect = container.getBoundingClientRect();
                            canvas.width = rect.width;
                            canvas.height = rect.height;
                            
                            console.log(`Canvas resized to ${canvas.width}x${canvas.height}`);
                        }
                    }
                    
                    // Update renderer layout
                    if (game.renderer && game.renderer.codebyart_updateLayout) {
                        game.renderer.codebyart_updateLayout();
                    }
                    
                    // Reposition UI elements
                    if (game.codebyart_updateLayout) {
                        game.codebyart_updateLayout();
                    }
                    
                    // Redraw the game
                    if (game.codebyart_render) {
                        game.codebyart_render();
                    }
                    
                    console.log('Layout updated for new orientation');
                }, 100);
            };
            
            // Listen for orientation change events
            window.addEventListener('orientationchange', handleOrientationChange);
            
            // Also listen for resize events (more reliable on some devices)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(handleOrientationChange, 150);
            });
            
            console.log('Orientation change handler initialized');
        }
        
        // ===== END GAME INITIALIZATION =====
        
        // ===== ANIMATION SYSTEM =====
        
        /**
         * AnimationManager - Manages smooth animations for modals, stars, and effects
         * Implements task 5: Smooth animation system
         */
        class codebyart_AnimationManager {
            constructor() {
                // Modal animation properties
                this.modalAnimations = new Map(); // Map of modal ID to animation state
                this.modalAnimationDuration = 300; // 300ms for modal transitions
                
                // Star selection animation properties
                this.starSelectionAnimations = new Map(); // Map of star ID to animation state
                this.starSelectionDuration = 400; // 400ms for star pulse
                
                // Connection line animation properties  
                this.connectionAnimations = new Map(); // Map of connection ID to animation state
                this.connectionDrawDuration = 200; // 200ms for line drawing
                
                // Celebration animation properties
                this.celebrationActive = false;
                this.celebrationStartTime = 0;
                this.celebrationDuration = 1000; // 1000ms for celebration
                this.celebrationParticles = [];
                
                console.log('AnimationManager initialized');
            }
            
            /**
             * Start modal animation (fade in + scale)
             * Task 5.1: Add modal transition animations
             * - Fade-in: opacity 0 to 1 over 300ms
             * - Scale: scale(0.9) to scale(1) over 300ms
             * - Backdrop blur: 0px to 10px over 300ms
             * @param {string} modalId - Unique identifier for the modal
             * @returns {Object} Animation state object
             */
            startModalAnimation(modalId) {
                const animation = {
                    id: modalId,
                    startTime: performance.now(),
                    duration: this.modalAnimationDuration,
                    progress: 0, // 0 to 1
                    opacity: 0, // 0 to 1
                    scale: 0.9, // 0.9 to 1.0
                    backdropBlur: 0, // 0 to 10px
                    active: true
                };
                
                this.modalAnimations.set(modalId, animation);
                console.log(`Modal animation started: ${modalId}`);
                return animation;
            }
            
            /**
             * Update modal animation state
             * Uses requestAnimationFrame for smooth rendering
             * @param {string} modalId - Modal identifier
             * @param {number} currentTime - Current timestamp from performance.now()
             * @returns {Object|null} Updated animation state or null if complete
             */
            updateModalAnimation(modalId, currentTime) {
                const animation = this.modalAnimations.get(modalId);
                if (!animation || !animation.active) return null;
                
                // Calculate progress (0 to 1)
                const elapsed = currentTime - animation.startTime;
                animation.progress = Math.min(1, elapsed / animation.duration);
                
                // Apply easing function (ease-out cubic)
                const eased = 1 - Math.pow(1 - animation.progress, 3);
                
                // Update animation properties
                animation.opacity = eased; // 0 to 1
                animation.scale = 0.9 + (eased * 0.1); // 0.9 to 1.0
                animation.backdropBlur = eased * 10; // 0 to 10px
                
                // Check if animation is complete
                if (animation.progress >= 1) {
                    animation.active = false;
                    console.log(`Modal animation complete: ${modalId}`);
                }
                
                return animation;
            }
            
            /**
             * Get current modal animation state
             * @param {string} modalId - Modal identifier
             * @returns {Object|null} Animation state or null if not found
             */
            getModalAnimation(modalId) {
                return this.modalAnimations.get(modalId) || null;
            }
            
            /**
             * Start star selection animation (pulse effect)
             * Task 5.2: Enhance star selection animations
             * - Pulse animation on star selection (400ms)
             * - Glow intensity: 0 to 1 to 0.5
             * - Size: baseSize to baseSize * 1.3 to baseSize
             * @param {number} starId - Star identifier
             * @param {number} baseSize - Base size of the star
             * @returns {Object} Animation state object
             */
            startStarSelectionAnimation(starId, baseSize) {
                const animation = {
                    id: starId,
                    startTime: performance.now(),
                    duration: this.starSelectionDuration,
                    progress: 0, // 0 to 1
                    glowIntensity: 0, // 0 to 1 to 0.5
                    sizeMultiplier: 1.0, // 1.0 to 1.3 to 1.0
                    baseSize: baseSize,
                    active: true
                };
                
                this.starSelectionAnimations.set(starId, animation);
                console.log(`Star selection animation started: ${starId}`);
                return animation;
            }
            
            /**
             * Update star selection animation state
             * @param {number} starId - Star identifier
             * @param {number} currentTime - Current timestamp
             * @returns {Object|null} Updated animation state or null if complete
             */
            updateStarSelectionAnimation(starId, currentTime) {
                const animation = this.starSelectionAnimations.get(starId);
                if (!animation || !animation.active) return null;
                
                // Calculate progress (0 to 1)
                const elapsed = currentTime - animation.startTime;
                animation.progress = Math.min(1, elapsed / animation.duration);
                
                // Pulse animation: 0 -> 1 -> 0.5 (using sine wave)
                // First half: 0 to 1 (0 to /2)
                // Second half: 1 to 0.5 (/2 to )
                if (animation.progress <= 0.5) {
                    // First half: grow from 0 to 1
                    const phase = animation.progress * 2; // 0 to 1
                    animation.glowIntensity = Math.sin(phase * Math.PI / 2); // 0 to 1
                    animation.sizeMultiplier = 1.0 + (animation.glowIntensity * 0.3); // 1.0 to 1.3
                } else {
                    // Second half: shrink from 1 to 0.5
                    const phase = (animation.progress - 0.5) * 2; // 0 to 1
                    animation.glowIntensity = 1.0 - (phase * 0.5); // 1.0 to 0.5
                    animation.sizeMultiplier = 1.3 - (phase * 0.3); // 1.3 to 1.0
                }
                
                // Check if animation is complete
                if (animation.progress >= 1) {
                    animation.active = false;
                    animation.glowIntensity = 0.5; // Final state
                    animation.sizeMultiplier = 1.0; // Final state
                    console.log(`Star selection animation complete: ${starId}`);
                }
                
                return animation;
            }
            
            /**
             * Get current star selection animation state
             * @param {number} starId - Star identifier
             * @returns {Object|null} Animation state or null if not found
             */
            getStarSelectionAnimation(starId) {
                return this.starSelectionAnimations.get(starId) || null;
            }
            
            /**
             * Start connection line drawing animation
             * Task 5.3: Add connection line drawing animation
             * - Animate line length from 0 to full over 200ms
             * - Animate opacity from 0 to 1 over 200ms
             * - Use linear interpolation for smooth drawing effect
             * @param {string} connectionId - Connection identifier (e.g., "0-1")
             * @param {Object} fromPos - Starting position {x, y}
             * @param {Object} toPos - Ending position {x, y}
             * @returns {Object} Animation state object
             */
            startConnectionAnimation(connectionId, fromPos, toPos) {
                const animation = {
                    id: connectionId,
                    startTime: performance.now(),
                    duration: this.connectionDrawDuration,
                    progress: 0, // 0 to 1
                    lineLength: 0, // 0 to 1 (percentage of full length)
                    opacity: 0, // 0 to 1
                    fromX: fromPos.x,
                    fromY: fromPos.y,
                    toX: toPos.x,
                    toY: toPos.y,
                    active: true
                };
                
                this.connectionAnimations.set(connectionId, animation);
                console.log(`Connection animation started: ${connectionId}`);
                return animation;
            }
            
            /**
             * Update connection animation state
             * @param {string} connectionId - Connection identifier
             * @param {number} currentTime - Current timestamp
             * @returns {Object|null} Updated animation state or null if complete
             */
            updateConnectionAnimation(connectionId, currentTime) {
                const animation = this.connectionAnimations.get(connectionId);
                if (!animation || !animation.active) return null;
                
                // Calculate progress (0 to 1) - linear interpolation
                const elapsed = currentTime - animation.startTime;
                animation.progress = Math.min(1, elapsed / animation.duration);
                
                // Update line length and opacity (linear)
                animation.lineLength = animation.progress; // 0 to 1
                animation.opacity = animation.progress; // 0 to 1
                
                // Check if animation is complete
                if (animation.progress >= 1) {
                    animation.active = false;
                    console.log(`Connection animation complete: ${connectionId}`);
                }
                
                return animation;
            }
            
            /**
             * Get current connection animation state
             * @param {string} connectionId - Connection identifier
             * @returns {Object|null} Animation state or null if not found
             */
            getConnectionAnimation(connectionId) {
                return this.connectionAnimations.get(connectionId) || null;
            }
            
            /**
             * Start level completion celebration animation
             * Task 5.4: Implement level completion celebration animation
             * - Create particle burst effect on level complete
             * - Add modal entrance animation with scale and fade
             * - Implement confetti or star particle effects
             */
            startCelebrationAnimation() {
                this.celebrationActive = true;
                this.celebrationStartTime = performance.now();
                this.celebrationParticles = [];
                
                // Create particle burst (confetti/stars)
                const particleCount = 50;
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const speed = 2 + Math.random() * 3;
                    const size = 3 + Math.random() * 5;
                    
                    // Random colors for confetti
                    const colors = [
                        { r: 255, g: 220, b: 100 }, // Gold
                        { r: 100, g: 255, b: 150 }, // Green
                        { r: 100, g: 200, b: 255 }, // Blue
                        { r: 255, g: 150, b: 200 }, // Pink
                        { r: 200, g: 150, b: 255 }  // Purple
                    ];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.celebrationParticles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: size,
                        color: color,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        life: 1.0 // 1.0 to 0
                    });
                }
                
                console.log('Celebration animation started');
            }
            
            /**
             * Update celebration animation state
             * @param {number} currentTime - Current timestamp
             * @param {number} deltaTime - Time since last frame in ms
             * @returns {boolean} True if animation is still active
             */
            updateCelebrationAnimation(currentTime, deltaTime) {
                if (!this.celebrationActive) return false;
                
                // Check if celebration is complete
                const elapsed = currentTime - this.celebrationStartTime;
                if (elapsed >= this.celebrationDuration) {
                    this.celebrationActive = false;
                    console.log('Celebration animation complete');
                    return false;
                }
                
                // Update particles
                const dt = deltaTime / 1000; // Convert to seconds
                this.celebrationParticles.forEach(particle => {
                    // Update position
                    particle.x += particle.vx * dt * 60;
                    particle.y += particle.vy * dt * 60;
                    
                    // Apply gravity
                    particle.vy += 0.15 * dt * 60;
                    
                    // Update rotation
                    particle.rotation += particle.rotationSpeed * dt * 60;
                    
                    // Update life (fade out)
                    particle.life = Math.max(0, 1 - (elapsed / this.celebrationDuration));
                });
                
                return true;
            }
            
            /**
             * Render celebration particles
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             */
            renderCelebrationParticles(ctx) {
                if (!this.celebrationActive || this.celebrationParticles.length === 0) return;
                
                ctx.save();
                
                this.celebrationParticles.forEach(particle => {
                    if (particle.life <= 0) return;
                    
                    ctx.save();
                    ctx.translate(particle.x, particle.y);
                    ctx.rotate(particle.rotation);
                    
                    // Draw particle with glow
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, particle.size * 2);
                    gradient.addColorStop(0, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.life})`);
                    gradient.addColorStop(0.5, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.life * 0.5})`);
                    gradient.addColorStop(1, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, particle.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw bright center
                    ctx.fillStyle = `rgba(255, 255, 255, ${particle.life * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, particle.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
                
                ctx.restore();
            }
            
            /**
             * Clear all animations
             */
            clearAll() {
                this.modalAnimations.clear();
                this.starSelectionAnimations.clear();
                this.connectionAnimations.clear();
                this.celebrationActive = false;
                this.celebrationParticles = [];
                console.log('All animations cleared');
            }
            
            /**
             * Update all active animations
             * Should be called every frame
             * @param {number} currentTime - Current timestamp from performance.now()
             * @param {number} deltaTime - Time since last frame in ms
             */
            updateAll(currentTime, deltaTime) {
                // Update modal animations
                this.modalAnimations.forEach((animation, id) => {
                    if (animation.active) {
                        this.updateModalAnimation(id, currentTime);
                    }
                });
                
                // Update star selection animations
                this.starSelectionAnimations.forEach((animation, id) => {
                    if (animation.active) {
                        this.updateStarSelectionAnimation(id, currentTime);
                    }
                });
                
                // Update connection animations
                this.connectionAnimations.forEach((animation, id) => {
                    if (animation.active) {
                        this.updateConnectionAnimation(id, currentTime);
                    }
                });
                
                // Update celebration animation
                if (this.celebrationActive) {
                    this.updateCelebrationAnimation(currentTime, deltaTime);
                }
            }
        }
        
        // Add AnimationManager to the game if it exists
        if (typeof window.codebyart_game !== 'undefined' && window.codebyart_game) {
            window.codebyart_game.animationManager = new codebyart_AnimationManager();
            console.log('AnimationManager added to game instance');
        }
        
        // ===== END ANIMATION SYSTEM =====
        
        // ===== PERFORMANCE OPTIMIZATION SYSTEM =====
        
        /**
         * codebyart_PerformanceMonitor - Monitors FPS and triggers performance degradation
         * Task 8.1: Add FPS monitoring and degradation system
         * - Implement FPS counter using requestAnimationFrame timestamps
         * - Detect performance issues (FPS < 30 for 3 seconds)
         * - Create fallback strategy: disable nebula, reduce stars, simplify effects
         */
        class codebyart_PerformanceMonitor {
            constructor() {
                // FPS tracking
                this.frameCount = 0;
                this.lastFrameTime = performance.now();
                this.lastFPSUpdate = performance.now();
                this.currentFPS = 60;
                this.fpsHistory = [];
                this.fpsHistorySize = 60; // Track last 60 frames (1 second at 60fps)
                
                // Performance degradation tracking
                this.lowFPSStartTime = null;
                this.lowFPSThreshold = 30; // FPS below this triggers degradation
                this.lowFPSDuration = 3000; // 3 seconds of low FPS triggers degradation
                this.performanceDegraded = false;
                
                // Performance settings
                this.settings = {
                    nebulaEnabled: true,
                    backgroundStarsEnabled: true,
                    backgroundStarCount: 150,
                    particleEffectsEnabled: true,
                    particleCount: 30,
                    blurQuality: 'high', // 'high', 'medium', 'low'
                    animationsEnabled: true
                };
                
                // Original settings backup
                this.originalSettings = { ...this.settings };
                
                // Device detection
                this.isMobile = this.detectMobile();
                this.isLowEndDevice = this.detectLowEndDevice();
                
                // Apply mobile optimizations immediately if needed
                if (this.isMobile) {
                    this.applyMobileOptimizations();
                }
                
                console.log('PerformanceMonitor initialized');
                console.log(`Device: ${this.isMobile ? 'Mobile' : 'Desktop'}, Low-end: ${this.isLowEndDevice}`);
            }
            
            /**
             * Detect if device is mobile
             * @returns {boolean} True if mobile device
             */
            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            /**
             * Detect if device is low-end (limited performance)
             * @returns {boolean} True if low-end device
             */
            detectLowEndDevice() {
                // Check for low memory devices
                if (navigator.deviceMemory && navigator.deviceMemory < 4) {
                    return true;
                }
                
                // Check for low core count
                if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) {
                    return true;
                }
                
                // Mobile devices are considered potentially low-end
                return this.isMobile;
            }
            
            /**
             * Update FPS counter with new frame
             * Should be called every frame from requestAnimationFrame
             * @param {number} currentTime - Current timestamp from performance.now()
             * @returns {number} Current FPS
             */
            updateFPS(currentTime) {
                // Calculate delta time
                const deltaTime = currentTime - this.lastFrameTime;
                this.lastFrameTime = currentTime;
                
                // Calculate instantaneous FPS
                const instantFPS = deltaTime > 0 ? 1000 / deltaTime : 60;
                
                // Add to history
                this.fpsHistory.push(instantFPS);
                if (this.fpsHistory.length > this.fpsHistorySize) {
                    this.fpsHistory.shift();
                }
                
                // Update average FPS every 100ms
                if (currentTime - this.lastFPSUpdate >= 100) {
                    this.currentFPS = this.calculateAverageFPS();
                    this.lastFPSUpdate = currentTime;
                    
                    // Check for performance degradation
                    this.checkPerformanceDegradation(currentTime);
                }
                
                this.frameCount++;
                return this.currentFPS;
            }
            
            /**
             * Calculate average FPS from history
             * @returns {number} Average FPS
             */
            calculateAverageFPS() {
                if (this.fpsHistory.length === 0) return 60;
                
                const sum = this.fpsHistory.reduce((a, b) => a + b, 0);
                return Math.round(sum / this.fpsHistory.length);
            }
            
            /**
             * Check if performance degradation should be triggered
             * @param {number} currentTime - Current timestamp
             */
            checkPerformanceDegradation(currentTime) {
                // Skip if already degraded
                if (this.performanceDegraded) return;
                
                // Check if FPS is below threshold
                if (this.currentFPS < this.lowFPSThreshold) {
                    // Start tracking low FPS duration
                    if (this.lowFPSStartTime === null) {
                        this.lowFPSStartTime = currentTime;
                        console.warn(`Low FPS detected: ${this.currentFPS} FPS`);
                    }
                    
                    // Check if low FPS has persisted for required duration
                    const lowFPSDuration = currentTime - this.lowFPSStartTime;
                    if (lowFPSDuration >= this.lowFPSDuration) {
                        console.warn(`Performance degradation triggered after ${(lowFPSDuration / 1000).toFixed(1)}s of low FPS`);
                        this.triggerPerformanceDegradation();
                    }
                } else {
                    // FPS recovered, reset tracking
                    if (this.lowFPSStartTime !== null) {
                        console.log(`FPS recovered: ${this.currentFPS} FPS`);
                        this.lowFPSStartTime = null;
                    }
                }
            }
            
            /**
             * Trigger performance degradation fallback strategy
             * Disables expensive visual effects to improve performance
             */
            triggerPerformanceDegradation() {
                if (this.performanceDegraded) return;
                
                console.warn(' PERFORMANCE DEGRADATION ACTIVATED');
                console.warn('Disabling expensive visual effects to improve performance...');
                
                // Disable nebula effects
                this.settings.nebulaEnabled = false;
                console.log('   Nebula effects disabled');
                
                // Reduce background stars by 50%
                this.settings.backgroundStarCount = Math.floor(this.originalSettings.backgroundStarCount * 0.5);
                console.log(`   Background stars reduced to ${this.settings.backgroundStarCount}`);
                
                // Disable particle effects
                this.settings.particleEffectsEnabled = false;
                console.log('   Particle effects disabled');
                
                // Reduce blur quality
                this.settings.blurQuality = 'low';
                console.log('   Blur quality reduced to low');
                
                this.performanceDegraded = true;
                
                // Notify user
                console.log('Performance optimizations applied. Game should run smoother now.');
            }
            
            /**
             * Apply mobile-specific performance optimizations
             * Task 8.3: Add mobile-specific performance optimizations
             * - Reduce canvas resolution on low-end devices
             * - Limit particle effect count on mobile (50% reduction)
             * - Use simpler blur effects on mobile devices
             */
            applyMobileOptimizations() {
                console.log('Applying mobile performance optimizations...');
                
                // Reduce particle count by 50%
                this.settings.particleCount = Math.floor(this.originalSettings.particleCount * 0.5);
                console.log(`   Particle count reduced to ${this.settings.particleCount} (50% reduction)`);
                
                // Use medium blur quality on mobile
                this.settings.blurQuality = 'medium';
                console.log('   Blur quality set to medium');
                
                // Reduce background stars on low-end devices
                if (this.isLowEndDevice) {
                    this.settings.backgroundStarCount = Math.floor(this.originalSettings.backgroundStarCount * 0.6);
                    console.log(`   Background stars reduced to ${this.settings.backgroundStarCount} (low-end device)`);
                }
            }
            
            /**
             * Get current FPS
             * @returns {number} Current FPS
             */
            getFPS() {
                return this.currentFPS;
            }
            
            /**
             * Get performance settings
             * @returns {Object} Current performance settings
             */
            getSettings() {
                return { ...this.settings };
            }
            
            /**
             * Check if performance is degraded
             * @returns {boolean} True if performance degradation is active
             */
            isPerformanceDegraded() {
                return this.performanceDegraded;
            }
            
            /**
             * Reset performance monitor to original settings
             */
            reset() {
                this.settings = { ...this.originalSettings };
                this.performanceDegraded = false;
                this.lowFPSStartTime = null;
                this.fpsHistory = [];
                console.log('PerformanceMonitor reset to original settings');
            }
            
            /**
             * Get performance statistics
             * @returns {Object} Performance stats
             */
            getStats() {
                return {
                    currentFPS: this.currentFPS,
                    averageFPS: this.calculateAverageFPS(),
                    minFPS: this.fpsHistory.length > 0 ? Math.min(...this.fpsHistory) : 60,
                    maxFPS: this.fpsHistory.length > 0 ? Math.max(...this.fpsHistory) : 60,
                    frameCount: this.frameCount,
                    performanceDegraded: this.performanceDegraded,
                    isMobile: this.isMobile,
                    isLowEndDevice: this.isLowEndDevice
                };
            }
        }
        
        /**
         * codebyart_CanvasOptimizer - Optimizes canvas rendering performance
         * Task 8.2: Optimize canvas rendering
         * - Implement dirty rectangle rendering for static elements
         * - Cache gradient objects to avoid recreation
         * - Use willReadFrequently flag for pixel operations
         * - Minimize canvas state changes
         */
        class codebyart_CanvasOptimizer {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                
                // Gradient cache
                this.gradientCache = new Map();
                
                // Dirty rectangle tracking
                this.dirtyRects = [];
                this.fullRedrawNeeded = true;
                
                // Canvas state tracking to minimize changes
                this.currentFillStyle = null;
                this.currentStrokeStyle = null;
                this.currentLineWidth = null;
                this.currentFont = null;
                this.currentGlobalAlpha = null;
                this.currentGlobalCompositeOperation = null;
                
                // Performance flags
                this.useWillReadFrequently = false;
                
                console.log('CanvasOptimizer initialized');
            }
            
            /**
             * Create or get cached gradient
             * Avoids recreating gradients every frame
             * @param {string} key - Unique key for gradient
             * @param {Function} createFn - Function to create gradient if not cached
             * @returns {CanvasGradient} Cached or new gradient
             */
            getCachedGradient(key, createFn) {
                if (this.gradientCache.has(key)) {
                    return this.gradientCache.get(key);
                }
                
                const gradient = createFn();
                this.gradientCache.set(key, gradient);
                return gradient;
            }
            
            /**
             * Create cached radial gradient
             * @param {string} key - Cache key
             * @param {number} x0 - Start circle X
             * @param {number} y0 - Start circle Y
             * @param {number} r0 - Start circle radius
             * @param {number} x1 - End circle X
             * @param {number} y1 - End circle Y
             * @param {number} r1 - End circle radius
             * @param {Array} colorStops - Array of {offset, color} objects
             * @returns {CanvasGradient} Cached gradient
             */
            createCachedRadialGradient(key, x0, y0, r0, x1, y1, r1, colorStops) {
                return this.getCachedGradient(key, () => {
                    const gradient = this.ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
                    colorStops.forEach(stop => {
                        gradient.addColorStop(stop.offset, stop.color);
                    });
                    return gradient;
                });
            }
            
            /**
             * Create cached linear gradient
             * @param {string} key - Cache key
             * @param {number} x0 - Start X
             * @param {number} y0 - Start Y
             * @param {number} x1 - End X
             * @param {number} y1 - End Y
             * @param {Array} colorStops - Array of {offset, color} objects
             * @returns {CanvasGradient} Cached gradient
             */
            createCachedLinearGradient(key, x0, y0, x1, y1, colorStops) {
                return this.getCachedGradient(key, () => {
                    const gradient = this.ctx.createLinearGradient(x0, y0, x1, y1);
                    colorStops.forEach(stop => {
                        gradient.addColorStop(stop.offset, stop.color);
                    });
                    return gradient;
                });
            }
            
            /**
             * Clear gradient cache
             * Call when canvas is resized
             */
            clearGradientCache() {
                this.gradientCache.clear();
                console.log('Gradient cache cleared');
            }
            
            /**
             * Set fill style with state tracking
             * Only updates if different from current state
             * @param {string|CanvasGradient} style - Fill style
             */
            setFillStyle(style) {
                if (this.currentFillStyle !== style) {
                    this.ctx.fillStyle = style;
                    this.currentFillStyle = style;
                }
            }
            
            /**
             * Set stroke style with state tracking
             * @param {string|CanvasGradient} style - Stroke style
             */
            setStrokeStyle(style) {
                if (this.currentStrokeStyle !== style) {
                    this.ctx.strokeStyle = style;
                    this.currentStrokeStyle = style;
                }
            }
            
            /**
             * Set line width with state tracking
             * @param {number} width - Line width
             */
            setLineWidth(width) {
                if (this.currentLineWidth !== width) {
                    this.ctx.lineWidth = width;
                    this.currentLineWidth = width;
                }
            }
            
            /**
             * Set font with state tracking
             * @param {string} font - Font string
             */
            setFont(font) {
                if (this.currentFont !== font) {
                    this.ctx.font = font;
                    this.currentFont = font;
                }
            }
            
            /**
             * Set global alpha with state tracking
             * @param {number} alpha - Alpha value (0-1)
             */
            setGlobalAlpha(alpha) {
                if (this.currentGlobalAlpha !== alpha) {
                    this.ctx.globalAlpha = alpha;
                    this.currentGlobalAlpha = alpha;
                }
            }
            
            /**
             * Set global composite operation with state tracking
             * @param {string} operation - Composite operation
             */
            setGlobalCompositeOperation(operation) {
                if (this.currentGlobalCompositeOperation !== operation) {
                    this.ctx.globalCompositeOperation = operation;
                    this.currentGlobalCompositeOperation = operation;
                }
            }
            
            /**
             * Reset state tracking
             * Call after ctx.save() or ctx.restore()
             */
            resetStateTracking() {
                this.currentFillStyle = null;
                this.currentStrokeStyle = null;
                this.currentLineWidth = null;
                this.currentFont = null;
                this.currentGlobalAlpha = null;
                this.currentGlobalCompositeOperation = null;
            }
            
            /**
             * Mark area as dirty for redraw
             * @param {number} x - X coordinate
             * @param {number} y - Y coordinate
             * @param {number} width - Width
             * @param {number} height - Height
             */
            markDirty(x, y, width, height) {
                this.dirtyRects.push({ x, y, width, height });
            }
            
            /**
             * Mark entire canvas for redraw
             */
            markFullRedraw() {
                this.fullRedrawNeeded = true;
                this.dirtyRects = [];
            }
            
            /**
             * Clear dirty rectangles
             * Call after rendering frame
             */
            clearDirtyRects() {
                this.dirtyRects = [];
                this.fullRedrawNeeded = false;
            }
            
            /**
             * Check if full redraw is needed
             * @returns {boolean} True if full redraw needed
             */
            needsFullRedraw() {
                return this.fullRedrawNeeded || this.dirtyRects.length > 10; // Too many dirty rects = full redraw
            }
            
            /**
             * Get dirty rectangles for partial rendering
             * @returns {Array} Array of dirty rectangles
             */
            getDirtyRects() {
                return this.dirtyRects;
            }
            
            /**
             * Enable willReadFrequently flag for pixel operations
             * Call before frequent getImageData operations
             */
            enableWillReadFrequently() {
                if (!this.useWillReadFrequently) {
                    // Note: This needs to be set when creating the context
                    // We can't change it after creation, but we track it for future reference
                    this.useWillReadFrequently = true;
                    console.log('willReadFrequently flag enabled (note: must be set at context creation)');
                }
            }
            
            /**
             * Get optimization statistics
             * @returns {Object} Optimization stats
             */
            getStats() {
                return {
                    cachedGradients: this.gradientCache.size,
                    dirtyRects: this.dirtyRects.length,
                    fullRedrawNeeded: this.fullRedrawNeeded
                };
            }
        }
        
        /**
         * codebyart_TouchEventDebouncer - Debounces touch events for mobile performance
         * Task 8.3: Add mobile-specific performance optimizations
         * - Debounce touch events (16ms)
         */
        class codebyart_TouchEventDebouncer {
            constructor(debounceDelay = 16) {
                this.debounceDelay = debounceDelay; // 16ms = ~60fps
                this.lastEventTime = 0;
                this.pendingEvent = null;
                this.timeoutId = null;
                
                console.log(`TouchEventDebouncer initialized with ${debounceDelay}ms delay`);
            }
            
            /**
             * Debounce a touch event
             * @param {Function} callback - Function to call with debounced event
             * @param {Event} event - Touch event
             * @returns {boolean} True if event was processed immediately
             */
            debounce(callback, event) {
                const currentTime = performance.now();
                const timeSinceLastEvent = currentTime - this.lastEventTime;
                
                // If enough time has passed, process immediately
                if (timeSinceLastEvent >= this.debounceDelay) {
                    this.lastEventTime = currentTime;
                    callback(event);
                    return true;
                }
                
                // Otherwise, schedule for later
                this.pendingEvent = { callback, event };
                
                // Clear existing timeout
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                }
                
                // Schedule new timeout
                const remainingTime = this.debounceDelay - timeSinceLastEvent;
                this.timeoutId = setTimeout(() => {
                    if (this.pendingEvent) {
                        this.lastEventTime = performance.now();
                        this.pendingEvent.callback(this.pendingEvent.event);
                        this.pendingEvent = null;
                    }
                }, remainingTime);
                
                return false;
            }
            
            /**
             * Clear pending events
             */
            clear() {
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
                this.pendingEvent = null;
            }
        }
        
        // Create global performance monitor instance
        window.codebyart_performanceMonitor = new codebyart_PerformanceMonitor();
        console.log('Global PerformanceMonitor created');
        
        // ===== END PERFORMANCE OPTIMIZATION SYSTEM =====
    </script>
</body>
</html>
